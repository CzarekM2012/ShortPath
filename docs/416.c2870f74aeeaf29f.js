(()=>{"use strict";var e,P={9416:(e,h,o)=>{var w=o(5595),i=o(6671),a=o(8610),b=o(6215),p=o(1507);const n="dist",c="pred",I="predKey";function _(s,u,m){const g=[];return g.push(a.X.setProperty(s,u.desc,n,u.dist)),g.push(a.X.setProperty(s,u.desc,I,m.desc.key)),g.push(a.X.setProperty(s,u.desc,c,m.label)),g}(0,b.d4)(n),(0,b.d4)(n),(0,b.d4)(n),addEventListener("message",({data:s})=>{const{graphData:u,source:m,destination:g}=s;!function j(s,u,m,g){const d={desc:new p.B(u,"node"),dist:0,label:s.getNodeAttribute(u,"label")};let r=new i.u;r.addChange(a.X.markElement(s,d.desc,"inspect")),r.addChange(a.X.setProperty(s,d.desc,n,d.dist));const A="starting node - no predecessor";r.addChange(a.X.setProperty(s,d.desc,c,A)),r.description=`Starting node (${d.desc}) is set as the current node, its dist is set to ${d.dist} and pred - to "${A}".\n      All nodes are considered to be unvisited.\n      Since paths leading nodes other than the starting one are unknown, their dist is set to Infinity and pred - to "?".`,g(r);let v=s.nodes(),f={desc:new p.B(u,"node"),dist:s.getNodeAttribute(u,n),label:s.getNodeAttribute(u,"label")};for(;f.desc.key!=m;){r=new i.u,s.forEachNeighbor(f.desc.key,$=>{if(v.includes($)){const l={desc:new p.B($,"node"),dist:s.getNodeAttribute($,n),label:s.getNodeAttribute($,"label")},E=s.edge(f.desc.key,$),y={desc:new p.B(E,"edge"),cost:s.getEdgeAttribute(E,"cost")},D=f.dist+y.cost;r.addChange(a.X.markElement(s,y.desc,"inspect")),r.description=`Edge connecting the current node (${f.label}) with its unvisited neighbour (${l.label}) is inspected. Length of path leading to ${l.label} using it is equal to ${D}`,D<l.dist?(r.description+=`Path from ${d.label} to ${l.label} using edge ${f.label}${l.label} is shorter than previous path between ${d.label} and ${l.label}.\n              "${(0,b.d4)(n)}" of ${l.label} is set to the length new path (${D})\n              Node ${f.label} is set as "pred" of ${l.label}.`,l.dist=D,r.addChange(..._(s,l,f))):r.description+=`Path from ${d.label} to ${l.label} using edge ${f.label}${l.label} is longer or equal to previous path between ${d.label} and ${l.label}.\n              Values describing ${l.label} remain unchanged.`,g(r),r=new i.u,r.addChange(a.X.markElement(s,y.desc,"reject"))}}),r.addChange(a.X.markElement(s,f.desc,"reject"));const C=v.indexOf(f.desc.key);v.splice(C,1),v.sort(($,l)=>s.getNodeAttribute($,n)-s.getNodeAttribute(l,n));const N={desc:new p.B(v[0],"node"),dist:s.getNodeAttribute(v[0],n),label:s.getNodeAttribute(v[0],"label")};r.addChange(a.X.markElement(s,N.desc,"inspect")),r.description=`All of the edges connecting current node (${f.label}) with its unvisited neighbours have been inspected.\n        ${f.label} is removed from the set of unvisited nodes.\n        Unvisited node with the lowest dist (${N.label}) choosen as new current node.\n        The shortest path between ${d.label} and ${N.label} has been found.`,g(r),f=N}r=new i.u,function U(s,u,m){const g=[new p.B(m,"node")];let d=m;for(;d!=u;){const r=s.getNodeAttribute(d,I);g.push(new p.B(r,"node"));const A=s.edge(d,r);g.push(new p.B(A,"edge")),d=r}return g}(s,u,m).forEach(C=>{r.addChange(a.X.markElement(s,C,"approve"))});const O=s.getNodeAttribute(m,"label");r.description=`Destination node (${O}) has been choosen as current.\n      The shortest path from the starting node (${d.label}) to ${O} has been found.\n      If algorithm were to continue until the set of unvisited nodes is empty, shortest paths from ${d.label} to all nodes would be found.`,g(r)}(w.UndirectedGraph.from(u),m,g,r=>{postMessage(r)})})}},x={};function t(e){var h=x[e];if(void 0!==h)return h.exports;var o=x[e]={exports:{}};return P[e].call(o.exports,o,o.exports,t),o.exports}t.m=P,t.x=()=>{var e=t.O(void 0,[419],()=>t(9416));return t.O(e)},e=[],t.O=(h,o,w,i)=>{if(!o){var b=1/0;for(a=0;a<e.length;a++){for(var[o,w,i]=e[a],p=!0,n=0;n<o.length;n++)(!1&i||b>=i)&&Object.keys(t.O).every(_=>t.O[_](o[n]))?o.splice(n--,1):(p=!1,i<b&&(b=i));if(p){e.splice(a--,1);var c=w();void 0!==c&&(h=c)}}return h}i=i||0;for(var a=e.length;a>0&&e[a-1][2]>i;a--)e[a]=e[a-1];e[a]=[o,w,i]},t.d=(e,h)=>{for(var o in h)t.o(h,o)&&!t.o(e,o)&&Object.defineProperty(e,o,{enumerable:!0,get:h[o]})},t.f={},t.e=e=>Promise.all(Object.keys(t.f).reduce((h,o)=>(t.f[o](e,h),h),[])),t.u=e=>e+".c5d6d40b0a071368.js",t.miniCssF=e=>{},t.o=(e,h)=>Object.prototype.hasOwnProperty.call(e,h),(()=>{var e;t.tt=()=>(void 0===e&&(e={createScriptURL:h=>h},typeof trustedTypes<"u"&&trustedTypes.createPolicy&&(e=trustedTypes.createPolicy("angular#bundler",e))),e)})(),t.tu=e=>t.tt().createScriptURL(e),t.p="",(()=>{var e={416:1};t.f.i=(i,a)=>{e[i]||importScripts(t.tu(t.p+t.u(i)))};var o=self.webpackChunkShortPath=self.webpackChunkShortPath||[],w=o.push.bind(o);o.push=i=>{var[a,b,p]=i;for(var n in b)t.o(b,n)&&(t.m[n]=b[n]);for(p&&p(t);a.length;)e[a.pop()]=1;w(i)}})(),(()=>{var e=t.x;t.x=()=>t.e(419).then(e)})(),t.x()})();