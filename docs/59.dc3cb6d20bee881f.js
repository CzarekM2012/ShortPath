(()=>{"use strict";var t,B={9416:(t,c,s)=>{var y=s(5595),a=s(6671),r=s(8610),f=s(1507);const d="distance",m="cost";addEventListener("message",({data:e})=>{const{graphData:h,source:k,destination:l}=e;!function b(e,h,k,l){const u=e.getNodeAttribute(h,"label");let o=new a.u;o.addChange(r.X.markElement(e,new f.B(h,"node"),"inspect")),o.addChange(r.X.setProperty(e,new f.B(h,"node"),d,0)),o.description=`Starting node (${u}) is set as the current node, its ${d} is set to 0.\n      All nodes are considered to be unvisited.\n      Since paths leading nodes other than the starting one are unknown, their ${d} is set to Infinity.`,l(o);let $=e.nodes(),i={key:h,dist:e.getNodeAttribute(h,d),label:e.getNodeAttribute(h,"label")};for(;i.key!=k;){o=new a.u,e.forEachNeighbor(i.key,w=>{if($.includes(w)){const g={key:w,dist:e.getNodeAttribute(w,d),label:e.getNodeAttribute(w,"label")},N=e.edge(i.key,g.key),O=e.getEdgeAttribute(N,m),x=i.dist+O;o.addChange(r.X.markElement(e,new f.B(N,"edge"),"inspect")),o.description=`Edge connecting the current node (${i.label}) with its unvisited neighbour (${g.label}) is inspected.\n`,x<g.dist?(o.addChange(r.X.setProperty(e,new f.B(g.key,"node"),d,x)),o.description+=`Sum of the ${d} of ${i.label} and the cost of the edge ${i.label}${g.label} (${i.dist} + ${O} = ${x}) is lower than the ${d} of ${g.label} (${g.dist}).\n              It means that using edge ${i.label}${g.label} creates a shorter path from ${u} to ${g.label}.\n              ${d} of ${g.label} is set to ${x}.`):o.description+=`Sum of the ${d} of ${i.label} and the cost of the edge ${i.label}${g.label} (${i.dist} + ${O} = ${x}) is higher than or equal to the ${d} of ${g.label} (${g.dist}).\n              It means that using edge ${i.label}-${g.label} does not create a shorter path from ${u} to ${g.label}.\n              Value of ${d} of ${g.label} does not change.`,l(o),o=new a.u,o.addChange(r.X.markElement(e,new f.B(N,"edge"),"reject"))}}),o.addChange(r.X.markElement(e,new f.B(i.key,"node"),"reject"));const C=$.indexOf(i.key);$.splice(C,1),$.sort((w,g)=>e.getNodeAttribute(w,d)-e.getNodeAttribute(g,d));const _={key:$[0],dist:e.getNodeAttribute($[0],d),label:e.getNodeAttribute($[0],"label")};o.addChange(r.X.markElement(e,new f.B(_.key,"node"),"inspect")),o.description=`All of the edges connecting current node (${i.label}) with its unvisited neighbours have been inspected.\n        ${i.label} is removed from the set of unvisited nodes.\n        Unvisited node with the lowest ${d} (${_.label}) choosen as new current node.`,l(o),i=_}o=new a.u,function p(e,h,k){const l=[new f.B(k,"node")];let u=k;for(;u!=h;){const o=e.getNodeAttribute(u,d),$=e.findNeighbor(u,(v,E)=>{const C=e.edge(u,v);return e.getEdgeAttribute(C,m)+E[d]==o});l.push(new f.B($,"node"));const i=e.edge(u,$);l.push(new f.B(i,"edge")),u=$}return l}(e,h,k).forEach(C=>{o.addChange(r.X.markElement(e,C,"approve"))});const E=e.getNodeAttribute(k,"label");o.description=`Destination node (${E}) has been choosen as current.\n      The shortest path from the starting node (${u}) to ${E} has been found.\n      If algorithm were to continue until the set of unvisited nodes is empty, shortest paths from ${u} to all nodes would be found.`,l(o)}(y.UndirectedGraph.from(h),k,l,o=>{postMessage(o)})})},6215:(t,c,s)=>{s.d(c,{ap:()=>d,hj:()=>f,k3:()=>m});var A,y=s(5149),a=s(8610),r=s(1507);function f(b,p,e){return"edge"==p.type?b.getEdgeAttribute(p.key,e):b.getNodeAttribute(p.key,e)}function d(b,p,e){return"edge"==p.type?b.removeEdgeAttribute(p.key,e):b.removeNodeAttribute(p.key,e)}function m(b,p,e,h){"edge"==p.type?b.setEdgeAttribute(p.key,e,h):b.setNodeAttribute(p.key,e,h)}!function(b){let p,e;(p=b.staticChecks||(b.staticChecks={})).isConnected=function k(l){const u=(0,y.dQ)(l);if(u.order==l.order)return{message:"",markings:[]};const o=[];return l.forEachNode($=>{u.hasNode($)||o.push(a.X.markElement(l,new r.B($,"node"),"error"))}),{message:"A path between any pair of nodes in graph must exist",markings:o}},(e=b.dynamicChecks||(b.dynamicChecks={})).areAttributesInRange=function k(l,u,o,$){const{min:i,max:v}=$;if(void 0===i&&void 0===v)return{message:"",markings:[]};if(void 0!==i&&void 0!==v&&!(i<=v))throw new Error("areAttributesInRange in range GraphCheck is called improperly, conditions min <= max should be met");const E=[];"edge"==u?l.forEachEdge(_=>{const w=l.getEdgeAttribute(_,o);(void 0!==i&&i>w||void 0!==v&&v<w)&&E.push(a.X.markElement(l,new r.B(_,u),"error"))}):l.forEachNode(_=>{const w=l.getNodeAttribute(_,o);(void 0!==i&&i>w||void 0!==v&&v<w)&&E.push(a.X.markElement(l,new r.B(_,u),"error"))});let C="";return E.length>0&&(C=`Value of ${o} on each ${u} must be ${void 0!==i?`higher than or equal to ${i}`:""}${void 0!==i&&void 0!==v?" and ":""}${void 0!==v?`lower than or equal to ${v}`:""}.`),{message:C,markings:E}}}(A||(A={}))}},P={};function n(t){var c=P[t];if(void 0!==c)return c.exports;var s=P[t]={exports:{}};return B[t].call(s.exports,s,s.exports,n),s.exports}n.m=B,n.x=()=>{var t=n.O(void 0,[681],()=>n(9416));return n.O(t)},t=[],n.O=(c,s,y,a)=>{if(!s){var f=1/0;for(r=0;r<t.length;r++){for(var[s,y,a]=t[r],d=!0,m=0;m<s.length;m++)(!1&a||f>=a)&&Object.keys(n.O).every(h=>n.O[h](s[m]))?s.splice(m--,1):(d=!1,a<f&&(f=a));if(d){t.splice(r--,1);var A=y();void 0!==A&&(c=A)}}return c}a=a||0;for(var r=t.length;r>0&&t[r-1][2]>a;r--)t[r]=t[r-1];t[r]=[s,y,a]},n.d=(t,c)=>{for(var s in c)n.o(c,s)&&!n.o(t,s)&&Object.defineProperty(t,s,{enumerable:!0,get:c[s]})},n.f={},n.e=t=>Promise.all(Object.keys(n.f).reduce((c,s)=>(n.f[s](t,c),c),[])),n.u=t=>t+".59d8dad51cac7c68.js",n.miniCssF=t=>{},n.o=(t,c)=>Object.prototype.hasOwnProperty.call(t,c),(()=>{var t;n.tt=()=>(void 0===t&&(t={createScriptURL:c=>c},typeof trustedTypes<"u"&&trustedTypes.createPolicy&&(t=trustedTypes.createPolicy("angular#bundler",t))),t)})(),n.tu=t=>n.tt().createScriptURL(t),n.p="",(()=>{var t={59:1};n.f.i=(a,r)=>{t[a]||importScripts(n.tu(n.p+n.u(a)))};var s=self.webpackChunkShortPath=self.webpackChunkShortPath||[],y=s.push.bind(s);s.push=a=>{var[r,f,d]=a;for(var m in f)n.o(f,m)&&(n.m[m]=f[m]);for(d&&d(n);r.length;)t[r.pop()]=1;y(a)}})(),(()=>{var t=n.x;n.x=()=>n.e(681).then(t)})(),n.x()})();