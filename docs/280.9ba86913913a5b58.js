(()=>{var o,F={9280:(o,u,n)=>{"use strict";var y=n(5595),f=n(4651),r=n(6671),h=n(8610),i=n(6215),g=n(1507);const p="dist",$="guess",v="pred",C="predecessorKey",w="cost";function E(e,a,c){const s=[];return s.push(h.X.setProperty(e,a.desc,p,a.dist)),s.push(h.X.setProperty(e,a.desc,$,a.heur)),s.push(h.X.setProperty(e,a.desc,C,c.desc.key)),s.push(h.X.setProperty(e,a.desc,v,c.label)),s}function k(e,a,c){const s=[new g.B(c,"node")];let b=c;for(;b!=a;){const d=e.getNodeAttribute(b,C);s.push(new g.B(d,"node"));const t=e.edge(b,d);s.push(new g.B(t,"edge")),b=d}return s}var P;!function(e){e.strings={descriptions:{general:'Algorithm for finding the shortest path between nodes in a graph with many uses, including: natural language parsing, navigation and computer games.\nIt works by extending paths starting in source node with neighboring them nodes, until destination node is found. Decision, which path should be extended and which node should be used for that, is based on value of heuristic function (approximation of the distance to the destination). For each of the nodes that can be used for extension of a path, length of the path that it would extend, length of the edge connecting it with the end of that path and value of heuristic function are added together, node which has the lowest value of this sum is choosen.\nPerformance of the algorithm is heavily impacted by the accuracy of the used heuristic. Its one major drawback is the fact that all encountered nodes are stored in memory and there are algorithms that outperform it because of that, but it is still the best solution in many cases.\n\nHeuristic function used in this implementation of the algorithm finds the minimum number of edges that needs to be traversed to move from the node to the destination and multiplies it by the "cost" of the shortest edge in the graph. Because of that, algorithm will be most effective on graphs with edges of similar length, on the other hand, graphs with both paths consisting of many short edges and those with fewer long edges will cause it to waste time extending paths with fewer edges. [1]',history:"This algorithm has been conceived at Stanford Research Institute, Nils J. Nilsson, Peter E. Hart and Bertram Raphael, members of the team that created \u201eShakey\u201d, one of the first mobile robots controlled by an artificial intelligence. It was developed for the robot's navigation system in order facilitate effective, safe navigation between two points, in environment with many obstacles.\n\nNilsson inspired by the method of heuristic search, proposed by J. Doran and Donald Michie [2], proposed considering orientation points, available for extending path in order of rising distance from destination in straight line, ignoring the obstacles. Raphael noticed that, the sum of distance traveled up to that point and Nilsson's approximation of remaining distance, would be a better criterion. They described this idea to Peter Hart, whose following actions are described by Nilsson in his book in following way:\n\n\u201cRaphael and I described this idea to Peter Hart, who had recently obtained a Ph.D. from Stanford and joined our group at SRI. Hart recalls \u201cgoing home that day, sitting in a particular chair and staring at the wall for more than an hour, and concluding\u201d that if the estimate of remaining distance (whatever it might be) was never larger than the actual remaining distance, then the use of such an estimate in our new scoring scheme would always find a path having the shortest distance to the goal. ( . . . ) Furthermore, he thought such a procedure would generate search trees no larger than any other procedures that were also guaranteed to find shortest paths and that used heuristic estimates no better than ours.\u201d\n\nAuthors managed to construct proofs for Hart's claims and named the resulting search process \u201eA*\u201d (\u201eA\u201d stood for algorithm and \u201e*\u201d denoted its property of finding shortest paths).\n\nSince its creation, A* has been expanded in many ways. Modifications authored by Richard Korf to make it more practical in situations, when available memory is limited are a good of such expansions. [3]",pseudocode:`// Read the path, by following predecessors of graph nodes\n// starting from target.\nfunction readPath(target, pred)\n   path := []\n   current := target\n   while current != UNDEFINED:\n      path.pushFront(current)\n      current := pred[current]\n   return path\n\n\nfunction A_Star(graph, source, target, heuristic)\n   // Step 1: Assign starting values of dist, ${$} and pred\n   //     for each node in graph\n   for each node in graph.nodes:\n      // Making dist, ${$} and pred data structures returning\n      // these starting values when trying to access values for\n      // missing keys may reduce the amount of required memory.\n      dist[node] := INFINITY\n      ${$}[node] := INFINITY\n      pred[node] := UNDEFINED\n   dist[source] := 0\n   ${$}[source] := heuristic(source)\n\n   openNodes := [source]\n   while openNodes is not empty\n      current := node in openNodes with min ${$}[node]\n\n   if current == target\n      return readPath(current, pred)\n\n   // Step 4: Remove current node from openNodes. Calculate lengths\n   //     of paths from source, through current, to each neighbour\n   //     of current. If new path is better, update description of\n   //     neighbour. Add updated, missing neighbours to openNodes\n   openNodes.remove(current)\n      for each neighbour of current\n         new${(0,i.d4)(p)} := dist[current] + cost(current, neighbour)\n         if new${(0,i.d4)(p)} < dist[neighbour]\n            dist[neighbour] := new${(0,i.d4)(p)}\n            ${$}[neighbour] := new${(0,i.d4)(p)} + heuristic(neighbour)\n            pred[neighbour] := current\n            if neighbour not in openNodes\n               openNodes.add(neighbour)\n\n   // All paths got extended as much as they could have been but\n   // goal was never reached\n   return FAILURE`,attributesDefinitions:{nodes:{[p]:"Length of the shortest path from the starting node to the node, can not be changed.",[$]:"Approximation of the length of the shortest path from the starting node to the destination node, leading through the node, can not be changed.",[v]:"Node that precedes the node on the path, can not be changed."},edges:{[w]:"Length of the edge, can be changed, needs to be a positive number, marked on graph visualisation."}},references:"[1] P. E. Hart, N. J. Nilsson i B. Raphael, \u201cA Formal Basis for the Heuristic Determination of Minimum Cost Paths\u201d, IEEE transactions on systems science and cybernetics, t. 4, nr. 2, p. 100\u2013107, 1968, ISSN: 0536-1567. DOI: 10.1109/TSSC.1968.300136.\n[2] J. E. Doran i D. Michie, \u201cExperiments with the Graph Traverser Program\u201d, Proceedings of the Royal Society of London. Series A, Mathematical and Physical Sciences, t. 294, nr. 1437, p. 235\u2013259, 1966, ISSN: 00804630. adr.: http://www.jstor.org/stable/ 2415467.\n[3] N. J. Nilsson, \u201cShakey, the SRI Robot\u201d, w The quest for artificial intelligence: a history of ideas and achievements, Cambridge University Press, 2010, p. 162\u2013176, ISBN: 978-0-521-11639-8 978-0-521-12293-1."},nodesAttributes:{distance:p,heuristic:$,predecessorLabel:v,predecessorKey:C},edgesAttributes:{cost:w}};const a="edges_from_destination",c="minimum_cost";function b(d,t){return d.getNodeAttribute(t,a)*d.getAttribute(c)}e.aStar=function s(d,t,A,N){d.setAttribute(c,function _(e){let a=1/0;return e.forEachEdge(c=>{const s=e.getEdgeAttribute(c,w);s<a&&(a=s)}),a}(d));const S=(0,f.jZ)(d,A);Object.entries(S).forEach(([R,I])=>{d.setNodeAttribute(R,a,I)}),function m(e,a,c,s,b){const d={desc:new g.B(a,"node"),dist:0,heur:b(e,a),label:e.getNodeAttribute(a,"label")};let t=new r.u;t.addChange(h.X.markElement(e,d.desc,"inspect")),t.addChange(h.X.setProperty(e,d.desc,p,d.dist)),t.addChange(h.X.setProperty(e,d.desc,$,d.heur));const A="starting node - no predecessor";t.addChange(h.X.setProperty(e,d.desc,v,A)),t.description=`Starting node (${d.label}) is the only node that can extend a path, its dist is set to ${d.dist}, ${$} - to the value of heuristic function (${d.heur}), and pred - to "${A}".\n          Since paths leading nodes other than the starting one are unknown, both their dist and ${$} are set to "Infinity" and their pred - to "?".`,s(t);const N=[{desc:new g.B(a,"node"),dist:e.getNodeAttribute(a,p),heur:e.getNodeAttribute(a,$),label:e.getNodeAttribute(a,"label")}];for(t=new r.u;N.length>0;){N.sort((I,O)=>I.heur-O.heur);const S=N[0];N.splice(0,1);const R=e.getNodeAttribute(S.desc.key,v);if(t.addChange(h.X.markElement(e,S.desc,"inspect")),t.description=`Node ${S.label} has the lowest value of ${$} from the set of nodes that can extend a path.\n        It extends the path leading through its predecessor (${R}), is choosen as current node and is removed from the set.`,s(t),S.desc.key==c){t=new r.u;const O=k(e,a,c).map(x=>h.X.markElement(e,x,"approve"));t.addChange(...O);const L=e.getNodeAttribute(c,"label");return t.description=`Destination node (${L}) has been choosen as current.\n      The shortest path from the starting node (${d.label}) to ${L} has been found.`,void s(t)}t=new r.u,e.forEachNeighbor(S.desc.key,I=>{const O=e.edge(S.desc.key,I),L={desc:new g.B(O,"edge"),cost:e.getEdgeAttribute(O,w)},x={desc:new g.B(I,"node"),dist:e.getNodeAttribute(I,p),heur:e.getNodeAttribute(I,$),label:e.getNodeAttribute(I,"label")},T=S.dist+L.cost;if(t.addChange(h.X.markElement(e,L.desc,"inspect")),t.description=`Length of the shortest path from starting node (${d.label}) to ${x.label} through current node (${S.label}) equals ${T}.\n`,T<x.dist){const D=T+b(e,x.desc.key);t.description+=`This path is shorter than the current path from ${d.label} to ${x.label} (${T} < ${x.dist}).\n            "${(0,i.d4)(p)}" of ${x.label} is set to the length of the shorter path (${T}).\n            "${(0,i.d4)($)}" of ${x.label} is set to new approximation of length of the path from the starting node to the destination node (${D}).\n            Node ${S.label} is set as "pred" of ${x.label}.\n            When ${x.label} will be choosen as current node, it will extend path leading through ${S.label}, unless shorter path that could be extended by it will be constructed beforehand.\n`,x.dist=T,x.heur=D,t.addChange(...E(e,x,S));const j=N.findIndex(U=>U.desc.isEqualTo(x.desc));-1!=j?(N[j]=x,t.description+=`${x.label} was already present in the set of nodes that can extend a path.`):(N.push(x),t.description+=`${x.label} is added to the set of nodes that can extend a path.`)}else{const D=e.getNodeAttribute(x.desc.key,v);t.description+=`This path is not shorter than the current path from ${d.label} to ${x.label} (${T} >= ${x.dist}).\n            When ${x.label} will be choosen as current node, it will extend path leading through its current predecessor (${D}), unless shorter path that could be extended by it will be constructed beforehand.`}s(t),t=new r.u,t.addChange(h.X.markElement(e,L.desc,"reject"))}),t.addChange(h.X.markElement(e,S.desc,"reject"))}t=new r.u,t.description="Set of available nodes is empty, but the path from source to destination was not found.\n      This should not be possible on a connected graph, with finite number of nodes and non-negative edge costs.\n      There is an error either in correctness checks of the algorithm or the implementation itself.",s(t)}(d,t,A,N,b),d.removeAttribute(c),d.forEachNode(R=>{d.removeNodeAttribute(R,a)})}}(P||(P={})),addEventListener("message",({data:e})=>{const{graphData:a,source:c,destination:s}=e,b=y.UndirectedGraph.from(a);P.aStar(b,c,s,d=>{postMessage(d)})})},3333:o=>{o.exports=function(n,y){var f=y.length;if(0!==f){var r=n.length;n.length+=f;for(var h=0;h<f;h++)n[r+h]=y[h]}}},4651:(o,u,n)=>{var f=n(6714),h=(n(7621),n(3333));function p(w,m,E){if(!f(m))throw new Error("graphology-shortest-path: invalid graphology instance.");if(!m.hasNode(E))throw new Error('graphology-shortest-path: the "'+E+'" source node does not exist in the given graph.');E=""+E;var k=new Set,P={},_=0;P[E]=0;for(var a,c,s,e=[E];0!==e.length;){var b=[];for(a=0,c=e.length;a<c;a++)!k.has(s=e[a])&&(k.add(s),h(b,m[w](s)),P[s]=_);_++,e=b}return P}var $=p.bind(null,"outboundNeighbors");p.bind(null,"neighbors");u.jZ=$},7621:(o,u,n)=>{var y=n(5701),f=n(4467);function r(){this.clear()}r.prototype.clear=function(){this.items=[],this.offset=0,this.size=0},r.prototype.enqueue=function(h){return this.items.push(h),++this.size},r.prototype.dequeue=function(){if(this.size){var h=this.items[this.offset];return 2*++this.offset>=this.items.length&&(this.items=this.items.slice(this.offset),this.offset=0),this.size--,h}},r.prototype.peek=function(){if(this.size)return this.items[this.offset]},r.prototype.forEach=function(h,i){i=arguments.length>1?i:this;for(var g=this.offset,p=0,$=this.items.length;g<$;g++,p++)h.call(i,this.items[g],p,this)},r.prototype.toArray=function(){return this.items.slice(this.offset)},r.prototype.values=function(){var h=this.items,i=this.offset;return new y(function(){if(i>=h.length)return{done:!0};var g=h[i];return i++,{value:g,done:!1}})},r.prototype.entries=function(){var h=this.items,i=this.offset,g=0;return new y(function(){if(i>=h.length)return{done:!0};var p=h[i];return i++,{value:[g++,p],done:!1}})},typeof Symbol<"u"&&(r.prototype[Symbol.iterator]=r.prototype.values),r.prototype.toString=function(){return this.toArray().join(",")},r.prototype.toJSON=function(){return this.toArray()},r.prototype.inspect=function(){var h=this.toArray();return Object.defineProperty(h,"constructor",{value:r,enumerable:!1}),h},typeof Symbol<"u"&&(r.prototype[Symbol.for("nodejs.util.inspect.custom")]=r.prototype.inspect),r.from=function(h){var i=new r;return f(h,function(g){i.enqueue(g)}),i},r.of=function(){return r.from(arguments)},o.exports=r},4467:(o,u,n)=>{var y=n(8123),f=y.ARRAY_BUFFER_SUPPORT,r=y.SYMBOL_SUPPORT;o.exports=function(i,g){var p,$,v,C,w;if(!i)throw new Error("obliterator/forEach: invalid iterable.");if("function"!=typeof g)throw new Error("obliterator/forEach: expecting a callback.");if(Array.isArray(i)||f&&ArrayBuffer.isView(i)||"string"==typeof i||"[object Arguments]"===i.toString())for(v=0,C=i.length;v<C;v++)g(i[v],v);else if("function"!=typeof i.forEach)if(r&&Symbol.iterator in i&&"function"!=typeof i.next&&(i=i[Symbol.iterator]()),"function"!=typeof i.next)for($ in i)i.hasOwnProperty($)&&g(i[$],$);else for(p=i,v=0;!0!==(w=p.next()).done;)g(w.value,v),v++;else i.forEach(g)}},5701:o=>{function u(n){if("function"!=typeof n)throw new Error("obliterator/iterator: expecting a function!");this.next=n}typeof Symbol<"u"&&(u.prototype[Symbol.iterator]=function(){return this}),u.of=function(){var n=arguments,y=n.length,f=0;return new u(function(){return f>=y?{done:!0}:{done:!1,value:n[f++]}})},u.empty=function(){return new u(function(){return{done:!0}})},u.fromSequence=function(n){var y=0,f=n.length;return new u(function(){return y>=f?{done:!0}:{done:!1,value:n[y++]}})},u.is=function(n){return n instanceof u||"object"==typeof n&&null!==n&&"function"==typeof n.next},o.exports=u},8123:(o,u)=>{u.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",u.SYMBOL_SUPPORT=typeof Symbol<"u"}},B={};function l(o){var u=B[o];if(void 0!==u)return u.exports;var n=B[o]={exports:{}};return F[o].call(n.exports,n,n.exports,l),n.exports}l.m=F,l.x=()=>{var o=l.O(void 0,[419],()=>l(9280));return l.O(o)},o=[],l.O=(u,n,y,f)=>{if(!n){var h=1/0;for(r=0;r<o.length;r++){for(var[n,y,f]=o[r],i=!0,g=0;g<n.length;g++)(!1&f||h>=f)&&Object.keys(l.O).every(m=>l.O[m](n[g]))?n.splice(g--,1):(i=!1,f<h&&(h=f));if(i){o.splice(r--,1);var p=y();void 0!==p&&(u=p)}}return u}f=f||0;for(var r=o.length;r>0&&o[r-1][2]>f;r--)o[r]=o[r-1];o[r]=[n,y,f]},l.d=(o,u)=>{for(var n in u)l.o(u,n)&&!l.o(o,n)&&Object.defineProperty(o,n,{enumerable:!0,get:u[n]})},l.f={},l.e=o=>Promise.all(Object.keys(l.f).reduce((u,n)=>(l.f[n](o,u),u),[])),l.u=o=>o+".c5d6d40b0a071368.js",l.miniCssF=o=>{},l.o=(o,u)=>Object.prototype.hasOwnProperty.call(o,u),(()=>{var o;l.tt=()=>(void 0===o&&(o={createScriptURL:u=>u},typeof trustedTypes<"u"&&trustedTypes.createPolicy&&(o=trustedTypes.createPolicy("angular#bundler",o))),o)})(),l.tu=o=>l.tt().createScriptURL(o),l.p="",(()=>{var o={280:1};l.f.i=(f,r)=>{o[f]||importScripts(l.tu(l.p+l.u(f)))};var n=self.webpackChunkShortPath=self.webpackChunkShortPath||[],y=n.push.bind(n);n.push=f=>{var[r,h,i]=f;for(var g in h)l.o(h,g)&&(l.m[g]=h[g]);for(i&&i(l);r.length;)o[r.pop()]=1;y(f)}})(),(()=>{var o=l.x;l.x=()=>l.e(419).then(o)})(),l.x()})();