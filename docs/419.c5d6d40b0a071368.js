(self.webpackChunkShortPath=self.webpackChunkShortPath||[]).push([[419],{6671:(H,N,v)=>{"use strict";v.d(N,{u:()=>b});var L=v(8610);class b{constructor(){this.changes=[],this.description=""}addChange(...x){x.forEach(m=>{const l=this.changes.findIndex(w=>{L.X.areRedundant(w,m)});-1!=l?this.changes[l]=m:this.changes.push(m)})}apply(x){const m=[];return this.changes.forEach(l=>{l.apply(x),m.push({element:l.element,attribute:l.property})}),m}reverse(x){const m=[];return this.changes.forEach(l=>{l.reverse(x),m.push({element:l.element,attribute:l.property})}),m}}},4855:(H,N,v)=>{"use strict";v.d(N,{I:()=>L});const L={graphMaxNodes:10,markingColors:{inspect:"yellow",approve:"green",reject:"red",choose:"#96c0e4",error:"black"}}},8610:(H,N,v)=>{"use strict";v.d(N,{X:()=>O});var L=v(4855),b=v(6215);class O{constructor(m,l,w,K){this.element=m,this.property=l,this.formerValue=w,this.newValue=K}static markElement(m,l,w){const K="color";let M=(0,b.hj)(m,l,K);M in[L.I.markingColors.choose,L.I.markingColors.error]&&(M=void 0);const S=new O(l,K,M,L.I.markingColors[w]);return S.apply(m),S}static setProperty(m,l,w,K){const M=(0,b.hj)(m,l,w);void 0===M&&console.error(`Attempt to set value of nonexistent ${l.type} property ${w}.`);const S=new O(l,w,M,K);return S.apply(m),S}static areRedundant(m,l){return m.element==l.element&&m.property==l.property}apply(m){(0,b.k3)(m,this.element,this.property,this.newValue)}reverse(m){void 0===this.formerValue?(0,b.ap)(m,this.element,this.property):(0,b.k3)(m,this.element,this.property,this.formerValue)}}},6215:(H,N,v)=>{"use strict";v.d(N,{ap:()=>m,d4:()=>K,hj:()=>x,k3:()=>l});var w,L=v(5149),b=v(8610),O=v(1507);function x(M,S,I){return"edge"==S.type?M.getEdgeAttribute(S.key,I):M.getNodeAttribute(S.key,I)}function m(M,S,I){return"edge"==S.type?M.removeEdgeAttribute(S.key,I):M.removeNodeAttribute(S.key,I)}function l(M,S,I,R){"edge"==S.type?M.setEdgeAttribute(S.key,I,R):M.setNodeAttribute(S.key,I,R)}function K(M){const S=M.slice(0,1),I=M.slice(1);return S.toUpperCase()+I}!function(M){let S,I;(S=M.staticChecks||(M.staticChecks={})).isConnected=function V(F){const _=(0,L.dQ)(F);if(_.order==F.order)return{message:"",markings:[]};const U=[];return F.forEachNode(A=>{_.hasNode(A)||U.push(b.X.markElement(F,new O.B(A,"node"),"error"))}),{message:"A path between any pair of nodes in graph must exist",markings:U}},(I=M.dynamicChecks||(M.dynamicChecks={})).areAttributesInRange=function V(F,_,U,A){const{min:D,max:C}=A;if(void 0===D&&void 0===C)return{message:"",markings:[]};if(void 0!==D&&void 0!==C&&!(D<=C))throw new Error("areAttributesInRange in range GraphCheck is called improperly, conditions min <= max should be met");const E=[];"edge"==_?F.forEachEdge(B=>{const T=F.getEdgeAttribute(B,U);(void 0!==D&&D>T||void 0!==C&&C<T)&&E.push(b.X.markElement(F,new O.B(B,_),"error"))}):F.forEachNode(B=>{const T=F.getNodeAttribute(B,U);(void 0!==D&&D>T||void 0!==C&&C<T)&&E.push(b.X.markElement(F,new O.B(B,_),"error"))});let z="";return E.length>0&&(z=`Value of ${U} on each ${_} must be ${void 0!==D?`higher than or equal to ${D}`:""}${void 0!==D&&void 0!==C?" and ":""}${void 0!==C?`lower than or equal to ${C}`:""}.`),{message:z,markings:E}}}(w||(w={}))},1507:(H,N,v)=>{"use strict";v.d(N,{B:()=>L});class L{constructor(O,x){this.key=O,this.type=x}isEqualTo(O){return this.key==O.key&&this.type==O.type}}},5149:(H,N,v)=>{var b=v(6714),O=v(6262).B,x=v(778).De,m=v(3882);N.dQ=function R(_){var U=function I(_){if(!b(_))throw new Error("graphology-components: the given graph is not a valid graphology instance.");if(!_.order)return[];var C,U=new m(_),A=U.push.bind(U),D=[];return U.forEachNodeYetUnseen(function(E){C=[],U.push(E);for(var z;0!==U.size;)z=U.pop(),C.push(z),_.forEachNeighbor(z,A);return C.length>D.length&&(D=C),D.length>U.countUnseenNodes()}),D}(_),A=_.nullCopy();return U.forEach(function(D){O(A,D,_.getNodeAttributes(D))}),_.forEachEdge(function(D,C,E,z,B,T,Z){A.hasNode(E)&&x(A,Z,D,E,z,C)}),A}},3882:H=>{function N(v){this.graph=v,this.stack=new Array(v.order),this.seen=new Set,this.size=0}N.prototype.hasAlreadySeenEverything=function(){return this.seen.size===this.graph.order},N.prototype.countUnseenNodes=function(){return this.graph.order-this.seen.size},N.prototype.forEachNodeYetUnseen=function(v){var L=this.seen,b=this.graph;b.someNode(function(O,x){return L.size===b.order||!L.has(O)&&!!v(O,x)})},N.prototype.has=function(v){return this.seen.has(v)},N.prototype.push=function(v){var L=this.seen.size;return this.seen.add(v),L!==this.seen.size&&(this.stack[this.size++]=v,!0)},N.prototype.pushWith=function(v,L){var b=this.seen.size;return this.seen.add(v),b!==this.seen.size&&(this.stack[this.size++]=L,!0)},N.prototype.pop=function(){if(0!==this.size)return this.stack[--this.size]},H.exports=N},778:(H,N)=>{N.De=function(b,O,x,m,l,w){return w=Object.assign({},w),O?null==x?b.addUndirectedEdge(m,l,w):b.addUndirectedEdgeWithKey(x,m,l,w):null==x?b.addDirectedEdge(m,l,w):b.addDirectedEdgeWithKey(x,m,l,w)}},6262:(H,N)=>{N.B=function(v,L,b){return b=Object.assign({},b),v.addNode(L,b)}},6714:H=>{H.exports=function(v){return null!==v&&"object"==typeof v&&"function"==typeof v.addUndirectedEdgeWithKey&&"function"==typeof v.dropNode&&"boolean"==typeof v.multi}},5595:function(H){H.exports=function(){"use strict";function N(n){return(N="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o})(n)}function v(n,o){n.prototype=Object.create(o.prototype),n.prototype.constructor=n,b(n,o)}function L(n){return(L=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)})(n)}function b(n,o){return(b=Object.setPrototypeOf||function(i,e){return i.__proto__=e,i})(n,o)}function O(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function x(n,o,i){return(x=O()?Reflect.construct:function(e,t,r){var a=[null];a.push.apply(a,t);var u=new(Function.bind.apply(e,a));return r&&b(u,r.prototype),u}).apply(null,arguments)}function m(n){var o="function"==typeof Map?new Map:void 0;return m=function(i){if(null===i||-1===Function.toString.call(i).indexOf("[native code]"))return i;if("function"!=typeof i)throw new TypeError("Super expression must either be null or a function");if(void 0!==o){if(o.has(i))return o.get(i);o.set(i,t)}function t(){return x(i,arguments,L(this).constructor)}return t.prototype=Object.create(i.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),b(t,i)},m(n)}function l(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}var w=function(){for(var n=arguments[0],o=1,i=arguments.length;o<i;o++)if(arguments[o])for(var e in arguments[o])n[e]=arguments[o][e];return n};function K(n,o,i,e){var t=n._nodes.get(o),r=null;return t?r="mixed"===e?t.out&&t.out[i]||t.undirected&&t.undirected[i]:"directed"===e?t.out&&t.out[i]:t.undirected&&t.undirected[i]:r}function M(n){return null!==n&&"object"===N(n)&&"function"==typeof n.addUndirectedEdgeWithKey&&"function"==typeof n.dropNode}function S(n){return"object"===N(n)&&null!==n&&n.constructor===Object}function I(n){var o;for(o in n)return!1;return!0}function R(n,o,i){Object.defineProperty(n,o,{enumerable:!1,configurable:!1,writable:!0,value:i})}function V(n,o,i){var e={enumerable:!0,configurable:!0};"function"==typeof i?e.get=i:(e.value=i,e.writable=!1),Object.defineProperty(n,o,e)}function F(n){return!(!S(n)||n.attributes&&!Array.isArray(n.attributes))}"function"==typeof Object.assign&&(w=Object.assign);var _,U={exports:{}},A="object"==typeof Reflect?Reflect:null,D=A&&"function"==typeof A.apply?A.apply:function(n,o,i){return Function.prototype.apply.call(n,o,i)};_=A&&"function"==typeof A.ownKeys?A.ownKeys:Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:function(n){return Object.getOwnPropertyNames(n)};var C=Number.isNaN||function(n){return n!=n};function E(){E.init.call(this)}U.exports=E,U.exports.once=function(n,o){return new Promise(function(i,e){function t(a){n.removeListener(o,r),e(a)}function r(){"function"==typeof n.removeListener&&n.removeListener("error",t),i([].slice.call(arguments))}var a;ae(n,o,r,{once:!0}),"error"!==o&&("function"==typeof(a=n).on&&ae(a,"error",t,{once:!0}))})},E.EventEmitter=E,E.prototype._events=void 0,E.prototype._eventsCount=0,E.prototype._maxListeners=void 0;var z=10;function B(n){if("function"!=typeof n)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}function T(n){return void 0===n._maxListeners?E.defaultMaxListeners:n._maxListeners}function Z(n,o,i,e){var t,r,a;if(B(i),void 0===(r=n._events)?(r=n._events=Object.create(null),n._eventsCount=0):(void 0!==r.newListener&&(n.emit("newListener",o,i.listener?i.listener:i),r=n._events),a=r[o]),void 0===a)a=r[o]=i,++n._eventsCount;else if("function"==typeof a?a=r[o]=e?[i,a]:[a,i]:e?a.unshift(i):a.push(i),(t=T(n))>0&&a.length>t&&!a.warned){a.warned=!0;var s=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(o)+" listeners added. Use emitter.setMaxListeners() to increase limit");s.name="MaxListenersExceededWarning",s.emitter=n,s.type=o,s.count=a.length,console&&console.warn&&console.warn(s)}return n}function se(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function te(n,o,i){var e={fired:!1,wrapFn:void 0,target:n,type:o,listener:i},t=se.bind(e);return t.listener=i,e.wrapFn=t,t}function oe(n,o,i){var e=n._events;if(void 0===e)return[];var t=e[o];return void 0===t?[]:"function"==typeof t?i?[t.listener||t]:[t]:i?function(r){for(var a=new Array(r.length),u=0;u<a.length;++u)a[u]=r[u].listener||r[u];return a}(t):ne(t,t.length)}function pe(n){var o=this._events;if(void 0!==o){var i=o[n];if("function"==typeof i)return 1;if(void 0!==i)return i.length}return 0}function ne(n,o){for(var i=new Array(o),e=0;e<o;++e)i[e]=n[e];return i}function ae(n,o,i,e){if("function"==typeof n.on)e.once?n.once(o,i):n.on(o,i);else{if("function"!=typeof n.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n);n.addEventListener(o,function t(r){e.once&&n.removeEventListener(o,t),i(r)})}}function q(n){if("function"!=typeof n)throw new Error("obliterator/iterator: expecting a function!");this.next=n}Object.defineProperty(E,"defaultMaxListeners",{enumerable:!0,get:function(){return z},set:function(n){if("number"!=typeof n||n<0||C(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");z=n}}),E.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},E.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||C(n))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+n+".");return this._maxListeners=n,this},E.prototype.getMaxListeners=function(){return T(this)},E.prototype.emit=function(n){for(var o=[],i=1;i<arguments.length;i++)o.push(arguments[i]);var e="error"===n,t=this._events;if(void 0!==t)e=e&&void 0===t.error;else if(!e)return!1;if(e){var r;if(o.length>0&&(r=o[0]),r instanceof Error)throw r;var a=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw a.context=r,a}var u=t[n];if(void 0===u)return!1;if("function"==typeof u)D(u,this,o);else{var s=u.length,c=ne(u,s);for(i=0;i<s;++i)D(c[i],this,o)}return!0},E.prototype.on=E.prototype.addListener=function(n,o){return Z(this,n,o,!1)},E.prototype.prependListener=function(n,o){return Z(this,n,o,!0)},E.prototype.once=function(n,o){return B(o),this.on(n,te(this,n,o)),this},E.prototype.prependOnceListener=function(n,o){return B(o),this.prependListener(n,te(this,n,o)),this},E.prototype.off=E.prototype.removeListener=function(n,o){var i,e,t,r,a;if(B(o),void 0===(e=this._events))return this;if(void 0===(i=e[n]))return this;if(i===o||i.listener===o)0==--this._eventsCount?this._events=Object.create(null):(delete e[n],e.removeListener&&this.emit("removeListener",n,i.listener||o));else if("function"!=typeof i){for(t=-1,r=i.length-1;r>=0;r--)if(i[r]===o||i[r].listener===o){a=i[r].listener,t=r;break}if(t<0)return this;0===t?i.shift():function(u,s){for(;s+1<u.length;s++)u[s]=u[s+1];u.pop()}(i,t),1===i.length&&(e[n]=i[0]),void 0!==e.removeListener&&this.emit("removeListener",n,a||o)}return this},E.prototype.removeAllListeners=function(n){var o,i,e;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[n]&&(0==--this._eventsCount?this._events=Object.create(null):delete i[n]),this;if(0===arguments.length){var t,r=Object.keys(i);for(e=0;e<r.length;++e)"removeListener"!==(t=r[e])&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(o=i[n]))this.removeListener(n,o);else if(void 0!==o)for(e=o.length-1;e>=0;e--)this.removeListener(n,o[e]);return this},E.prototype.listeners=function(n){return oe(this,n,!0)},E.prototype.rawListeners=function(n){return oe(this,n,!1)},E.listenerCount=function(n,o){return"function"==typeof n.listenerCount?n.listenerCount(o):pe.call(n,o)},E.prototype.listenerCount=pe,E.prototype.eventNames=function(){return this._eventsCount>0?_(this._events):[]},typeof Symbol<"u"&&(q.prototype[Symbol.iterator]=function(){return this}),q.of=function(){var n=arguments,o=n.length,i=0;return new q(function(){return i>=o?{done:!0}:{done:!1,value:n[i++]}})},q.empty=function(){return new q(function(){return{done:!0}})},q.fromSequence=function(n){var o=0,i=n.length;return new q(function(){return o>=i?{done:!0}:{done:!1,value:n[o++]}})},q.is=function(n){return n instanceof q||"object"==typeof n&&null!==n&&"function"==typeof n.next};var $=q,ce={};ce.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",ce.SYMBOL_SUPPORT=typeof Symbol<"u";var we=$,Te=ce.ARRAY_BUFFER_SUPPORT,Fe=ce.SYMBOL_SUPPORT,De=function(n){var i,o="string"==typeof(i=n)||Array.isArray(i)||Te&&ArrayBuffer.isView(i)?we.fromSequence(i):"object"!=typeof i||null===i?null:Fe&&"function"==typeof i[Symbol.iterator]?i[Symbol.iterator]():"function"==typeof i.next?i:null;if(!o)throw new Error("obliterator: target is not iterable nor a valid iterator.");return o},Ye=De,Se=function(n,o){for(var i,e=arguments.length>1?o:1/0,t=e!==1/0?new Array(e):[],r=0,a=Ye(n);;){if(r===e)return t;if((i=a.next()).done)return r!==o&&(t.length=r),t;t[r++]=i.value}},be=function(n){function o(i){var e;return(e=n.call(this)||this).name="GraphError",e.message=i,e}return v(o,n),o}(m(Error)),y=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(l(e),o.prototype.constructor),e}return v(o,n),o}(be),f=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(l(e),o.prototype.constructor),e}return v(o,n),o}(be),G=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(l(e),o.prototype.constructor),e}return v(o,n),o}(be);function Ue(n,o){this.key=n,this.attributes=o,this.clear()}function Le(n,o){this.key=n,this.attributes=o,this.clear()}function Ce(n,o){this.key=n,this.attributes=o,this.clear()}function de(n,o,i,e,t){this.key=o,this.attributes=t,this.undirected=n,this.source=i,this.target=e}function re(n,o,i,e,t,r,a){var u,s,c,h;if(e=""+e,0===i){if(!(u=n._nodes.get(e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));c=t,h=r}else if(3===i){if(!(s=n._edges.get(t=""+t)))throw new f("Graph.".concat(o,': could not find the "').concat(t,'" edge in the graph.'));var d=s.source.key,g=s.target.key;if(e===d)u=s.target;else{if(e!==g)throw new f("Graph.".concat(o,': the "').concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(d,", ").concat(g,")."));u=s.source}c=r,h=a}else{if(!(s=n._edges.get(e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'));u=1===i?s.source:s.target,c=t,h=r}return[u,c,h]}Ue.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}},Le.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}},Ce.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}},de.prototype.attach=function(){var n="out",o="in";this.undirected&&(n=o="undirected");var i=this.source.key,e=this.target.key;this.source[n][e]=this,this.undirected&&i===e||(this.target[o][i]=this)},de.prototype.attachMulti=function(){var n="out",o="in",i=this.source.key,e=this.target.key;this.undirected&&(n=o="undirected");var t=this.source[n],r=t[e];if(void 0===r)return t[e]=this,void(this.undirected&&i===e||(this.target[o][i]=this));r.previous=this,this.next=r,t[e]=this,this.target[o][i]=this},de.prototype.detach=function(){var n=this.source.key,i="out",e="in";this.undirected&&(i=e="undirected"),delete this.source[i][this.target.key],delete this.target[e][n]},de.prototype.detachMulti=function(){var n=this.source.key,o=this.target.key,i="out",e="in";this.undirected&&(i=e="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[i][o],delete this.target[e][n]):(this.next.previous=void 0,this.source[i][o]=this.next,this.target[e][n]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};var Ve=[{name:function(n){return"get".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r);return a[0].attributes[a[1]]}}},{name:function(n){return"get".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){return re(this,o,i,e,t)[0].attributes}}},{name:function(n){return"has".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r);return a[0].attributes.hasOwnProperty(a[1])}}},{name:function(n){return"set".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r,a){var u=re(this,o,i,e,t,r,a),s=u[0],c=u[1];return s.attributes[c]=u[2],this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:c}),this}}},{name:function(n){return"update".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r,a){var u=re(this,o,i,e,t,r,a),s=u[0],c=u[1],h=u[2];if("function"!=typeof h)throw new y("Graph.".concat(o,": updater should be a function."));var d=s.attributes,g=h(d[c]);return d[c]=g,this.emit("nodeAttributesUpdated",{key:s.key,type:"set",attributes:s.attributes,name:c}),this}}},{name:function(n){return"remove".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),u=a[0],s=a[1];return delete u.attributes[s],this.emit("nodeAttributesUpdated",{key:u.key,type:"remove",attributes:u.attributes,name:s}),this}}},{name:function(n){return"replace".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),u=a[0],s=a[1];if(!S(s))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return u.attributes=s,this.emit("nodeAttributesUpdated",{key:u.key,type:"replace",attributes:u.attributes}),this}}},{name:function(n){return"merge".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),u=a[0],s=a[1];if(!S(s))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return w(u.attributes,s),this.emit("nodeAttributesUpdated",{key:u.key,type:"merge",attributes:u.attributes,data:s}),this}}},{name:function(n){return"update".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),u=a[0],s=a[1];if("function"!=typeof s)throw new y("Graph.".concat(o,": provided updater is not a function."));return u.attributes=s(u.attributes),this.emit("nodeAttributesUpdated",{key:u.key,type:"update",attributes:u.attributes}),this}}}],$e=[{name:function(n){return"get".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return r.attributes[t]}}},{name:function(n){return"get".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e){var t;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var r=""+e,a=""+arguments[1];if(!(t=K(this,r,a,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(r,'" - "').concat(a,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(t=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return t.attributes}}},{name:function(n){return"has".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return r.attributes.hasOwnProperty(t)}}},{name:function(n){return"set".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var u=""+e,s=""+t;if(t=arguments[2],r=arguments[3],!(a=K(this,u,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(u,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(a=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return a.attributes[t]=r,this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:t}),this}}},{name:function(n){return"update".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var u=""+e,s=""+t;if(t=arguments[2],r=arguments[3],!(a=K(this,u,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(u,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(a=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof r)throw new y("Graph.".concat(o,": updater should be a function."));return a.attributes[t]=r(a.attributes[t]),this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:t}),this}}},{name:function(n){return"remove".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return delete r.attributes[t],this.emit("edgeAttributesUpdated",{key:r.key,type:"remove",attributes:r.attributes,name:t}),this}}},{name:function(n){return"replace".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if(!S(t))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return r.attributes=t,this.emit("edgeAttributesUpdated",{key:r.key,type:"replace",attributes:r.attributes}),this}}},{name:function(n){return"merge".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if(!S(t))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return w(r.attributes,t),this.emit("edgeAttributesUpdated",{key:r.key,type:"merge",attributes:r.attributes,data:t}),this}}},{name:function(n){return"update".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new G("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new G("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,u=""+t;if(t=arguments[2],!(r=K(this,a,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new G("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof t)throw new y("Graph.".concat(o,": provided updater is not a function."));return r.attributes=t(r.attributes),this.emit("edgeAttributesUpdated",{key:r.key,type:"update",attributes:r.attributes}),this}}}],Xe=$,Qe=De,ie=function(){var n=arguments,o=null,i=-1;return new Xe(function(){for(var e=null;;){if(null===o){if(++i>=n.length)return{done:!0};o=Qe(n[i])}if(!0!==(e=o.next()).done)break;o=null}return e})},Je=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function He(n,o,i,e){var t=!1;for(var r in o)if(r!==e){var a=o[r];if(t=i(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),n&&t)return a.key}}function Ze(n,o,i,e){var t,r,a,u=!1;for(var s in o)if(s!==e){t=o[s];do{if(u=i(t.key,t.attributes,(r=t.source).key,(a=t.target).key,r.attributes,a.attributes,t.undirected),n&&u)return t.key;t=t.next}while(void 0!==t)}}function _e(n,o){var i,e=Object.keys(n),t=e.length,r=0;return new $(function(){do{if(i)i=i.next;else{if(r>=t)return{done:!0};var a=e[r++];if(a===o){i=void 0;continue}i=n[a]}}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}})}function qe(n,o,i,e){var t=o[i];if(t){var r=t.source,a=t.target;return e(t.key,t.attributes,r.key,a.key,r.attributes,a.attributes,t.undirected)&&n?t.key:void 0}}function et(n,o,i,e){var t=o[i];if(t){var r=!1;do{if(r=e(t.key,t.attributes,t.source.key,t.target.key,t.source.attributes,t.target.attributes,t.undirected),n&&r)return t.key;t=t.next}while(void 0!==t)}}function ke(n,o){var i=n[o];return void 0!==i.next?new $(function(){if(!i)return{done:!0};var e={edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected};return i=i.next,{done:!1,value:e}}):$.of({edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected})}function tt(n,o){if(0===n.size)return[];if("mixed"===o||o===n.type)return"function"==typeof Array.from?Array.from(n._edges.keys()):Se(n._edges.keys(),n._edges.size);for(var i,e,r=new Array("undirected"===o?n.undirectedSize:n.directedSize),a="undirected"===o,u=n._edges.values(),s=0;!0!==(i=u.next()).done;)(e=i.value).undirected===a&&(r[s++]=e.key);return r}function Ne(n,o,i,e){if(0!==o.size)for(var t,r,a="mixed"!==i&&i!==o.type,u="undirected"===i,s=!1,c=o._edges.values();!0!==(t=c.next()).done;)if(r=t.value,!a||r.undirected===u){var d=r.key,p=r.source,k=r.target;if(s=e(d,r.attributes,p.key,k.key,p.attributes,k.attributes,r.undirected),n&&s)return d}}function nt(n,o){if(0===n.size)return $.empty();var i="mixed"!==o&&o!==n.type,e="undirected"===o,t=n._edges.values();return new $(function(){for(var r,a;;){if((r=t.next()).done)return r;if(a=r.value,!i||a.undirected===e)break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function Ee(n,o,i,e,t,r){var a,u=o?Ze:He;if("undirected"!==i&&("out"!==e&&(a=u(n,t.in,r),n&&a)||"in"!==e&&(a=u(n,t.out,r,e?void 0:t.key),n&&a))||"directed"!==i&&(a=u(n,t.undirected,r),n&&a))return a}function rt(n,o,i,e){var t=[];return Ee(!1,n,o,i,e,function(r){t.push(r)}),t}function it(n,o,i){var e=$.empty();return"undirected"!==n&&("out"!==o&&void 0!==i.in&&(e=ie(e,_e(i.in))),"in"!==o&&void 0!==i.out&&(e=ie(e,_e(i.out,o?void 0:i.key)))),"directed"!==n&&void 0!==i.undirected&&(e=ie(e,_e(i.undirected))),e}function Ge(n,o,i,e,t,r,a){var u,s=i?et:qe;if("undirected"!==o&&(void 0!==t.in&&"out"!==e&&(u=s(n,t.in,r,a),n&&u)||void 0!==t.out&&"in"!==e&&(e||t.key!==r)&&(u=s(n,t.out,r,a),n&&u))||"directed"!==o&&void 0!==t.undirected&&(u=s(n,t.undirected,r,a),n&&u))return u}function ot(n,o,i,e,t){var r=[];return Ge(!1,n,o,i,e,t,function(a){r.push(a)}),r}function at(n,o,i,e){var t=$.empty();return"undirected"!==n&&(void 0!==i.in&&"out"!==o&&e in i.in&&(t=ie(t,ke(i.in,e))),void 0!==i.out&&"in"!==o&&e in i.out&&(o||i.key!==e)&&(t=ie(t,ke(i.out,e)))),"directed"!==n&&void 0!==i.undirected&&e in i.undirected&&(t=ie(t,ke(i.undirected,e))),t}var ut=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function ye(){this.A=null,this.B=null}function le(n,o,i,e,t){for(var r in e){var a=e[r],u=a.source,c=u===i?a.target:u;if(!o||!o.has(c.key)){var h=t(c.key,c.attributes);if(n&&h)return c.key}}}function xe(n,o,i,e,t){if("mixed"!==o){if("undirected"===o)return le(n,null,e,e.undirected,t);if("string"==typeof i)return le(n,null,e,e[i],t)}var r,a=new ye;if("undirected"!==o){if("out"!==i){if(r=le(n,null,e,e.in,t),n&&r)return r;a.wrap(e.in)}if("in"!==i){if(r=le(n,a,e,e.out,t),n&&r)return r;a.wrap(e.out)}}if("directed"!==o&&(r=le(n,a,e,e.undirected,t),n&&r))return r}function ge(n,o,i){var e=Object.keys(i),t=e.length,r=0;return new $(function(){var a=null;do{if(r>=t)return n&&n.wrap(i),{done:!0};var u=i[e[r++]],s=u.source;a=s===o?u.target:s,n&&n.has(a.key)&&(a=null)}while(null===a);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function me(n,o,i,e,t){for(var r,a,u,s,c,h,d,g=e._nodes.values(),p=e.type;!0!==(r=g.next()).done;){var k=!1;if(a=r.value,"undirected"!==p)for(u in s=a.out){c=s[u];do{if(k=!0,d=t(a.key,(h=c.target).key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),n&&d)return c;c=c.next}while(c)}if("directed"!==p)for(u in s=a.undirected)if(!(o&&a.key>u)){c=s[u];do{if((h=c.target).key!==u&&(h=c.source),k=!0,d=t(a.key,h.key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),n&&d)return c;c=c.next}while(c)}if(i&&!k&&(d=t(a.key,null,a.attributes,null,null,null,null),n&&d))return null}}function dt(n){if(!S(n))throw new y('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in n))throw new y("Graph.import: serialized node is missing its key.");if("attributes"in n&&(!S(n.attributes)||null===n.attributes))throw new y("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function ht(n){if(!S(n))throw new y('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in n))throw new y("Graph.import: serialized edge is missing its source.");if(!("target"in n))throw new y("Graph.import: serialized edge is missing its target.");if("attributes"in n&&(!S(n.attributes)||null===n.attributes))throw new y("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in n&&"boolean"!=typeof n.undirected)throw new y("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}ye.prototype.wrap=function(n){null===this.A?this.A=n:null===this.B&&(this.B=n)},ye.prototype.has=function(n){return null!==this.A&&n in this.A||null!==this.B&&n in this.B};var Oe,ft=(Oe=255&Math.floor(256*Math.random()),function(){return Oe++}),pt=new Set(["directed","undirected","mixed"]),ze=new Set(["domain","_events","_eventsCount","_maxListeners"]),lt={allowSelfLoops:!0,multi:!1,type:"mixed"};function je(n,o,i){var e=new n.NodeDataClass(o,i);return n._nodes.set(o,e),n.emit("nodeAdded",{key:o,attributes:i}),e}function Me(n,o,i,e,t,r,a,u){if(!e&&"undirected"===n.type)throw new G("Graph.".concat(o,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(e&&"directed"===n.type)throw new G("Graph.".concat(o,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(u&&!S(u))throw new y("Graph.".concat(o,': invalid attributes. Expecting an object but got "').concat(u,'"'));if(r=""+r,a=""+a,u=u||{},!n.allowSelfLoops&&r===a)throw new G("Graph.".concat(o,': source & target are the same ("').concat(r,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var s=n._nodes.get(r),c=n._nodes.get(a);if(!s)throw new f("Graph.".concat(o,': source node "').concat(r,'" not found.'));if(!c)throw new f("Graph.".concat(o,': target node "').concat(a,'" not found.'));var h={key:null,undirected:e,source:r,target:a,attributes:u};if(i)t=n._edgeKeyGenerator();else if(n._edges.has(t=""+t))throw new G("Graph.".concat(o,': the "').concat(t,'" edge already exists in the graph.'));if(!n.multi&&(e?void 0!==s.undirected[a]:void 0!==s.out[a]))throw new G("Graph.".concat(o,': an edge linking "').concat(r,'" to "').concat(a,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));var d=new de(e,t,s,c,u);n._edges.set(t,d);var g=r===a;return e?(s.undirectedDegree++,c.undirectedDegree++,g&&n._undirectedSelfLoopCount++):(s.outDegree++,c.inDegree++,g&&n._directedSelfLoopCount++),n.multi?d.attachMulti():d.attach(),e?n._undirectedSize++:n._directedSize++,h.key=t,n.emit("edgeAdded",h),t}function gt(n,o,i,e,t,r,a,u,s){if(!e&&"undirected"===n.type)throw new G("Graph.".concat(o,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(e&&"directed"===n.type)throw new G("Graph.".concat(o,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(u)if(s){if("function"!=typeof u)throw new y("Graph.".concat(o,': invalid updater function. Expecting a function but got "').concat(u,'"'))}else if(!S(u))throw new y("Graph.".concat(o,': invalid attributes. Expecting an object but got "').concat(u,'"'));var c;if(r=""+r,a=""+a,s&&(c=u,u=void 0),!n.allowSelfLoops&&r===a)throw new G("Graph.".concat(o,': source & target are the same ("').concat(r,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var h,d,g=n._nodes.get(r),p=n._nodes.get(a);if(!i&&(h=n._edges.get(t))){if(!(h.source.key===r&&h.target.key===a||e&&h.source.key===a&&h.target.key===r))throw new G("Graph.".concat(o,': inconsistency detected when attempting to merge the "').concat(t,'" edge with "').concat(r,'" source & "').concat(a,'" target vs. ("').concat(h.source.key,'", "').concat(h.target.key,'").'));d=h}if(d||n.multi||!g||(d=e?g.undirected[a]:g.out[a]),d){var k=[d.key,!1,!1,!1];return(s?c:u)?(s?(d.attributes=c(d.attributes),n.emit("edgeAttributesUpdated",{type:"replace",key:d.key,attributes:d.attributes})):(w(d.attributes,u),n.emit("edgeAttributesUpdated",{type:"merge",key:d.key,attributes:d.attributes,data:u})),k):k}u=u||{},s&&c&&(u=c(u));var P={key:null,undirected:e,source:r,target:a,attributes:u};if(i)t=n._edgeKeyGenerator();else if(n._edges.has(t=""+t))throw new G("Graph.".concat(o,': the "').concat(t,'" edge already exists in the graph.'));var X=!1,Y=!1;g||(g=je(n,r,{}),X=!0,r===a&&(p=g,Y=!0)),p||(p=je(n,a,{}),Y=!0),h=new de(e,t,g,p,u),n._edges.set(t,h);var Q=r===a;return e?(g.undirectedDegree++,p.undirectedDegree++,Q&&n._undirectedSelfLoopCount++):(g.outDegree++,p.inDegree++,Q&&n._directedSelfLoopCount++),n.multi?h.attachMulti():h.attach(),e?n._undirectedSize++:n._directedSize++,P.key=t,n.emit("edgeAdded",P),[t,!0,X,Y]}function he(n,o){n._edges.delete(o.key);var i=o.source,e=o.target,t=o.attributes,r=o.undirected,a=i===e;r?(i.undirectedDegree--,e.undirectedDegree--,a&&n._undirectedSelfLoopCount--):(i.outDegree--,e.inDegree--,a&&n._directedSelfLoopCount--),n.multi?o.detachMulti():o.detach(),r?n._undirectedSize--:n._directedSize--,n.emit("edgeDropped",{key:o.key,attributes:t,source:i.key,target:e.key,undirected:r})}var n,W=function(n){function o(e){var t;if(t=n.call(this)||this,"boolean"!=typeof(e=w({},lt,e)).multi)throw new y("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(e.multi,'".'));if(!pt.has(e.type))throw new y('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(e.type,'".'));if("boolean"!=typeof e.allowSelfLoops)throw new y("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(e.allowSelfLoops,'".'));var r="mixed"===e.type?Ue:"directed"===e.type?Le:Ce;R(l(t),"NodeDataClass",r);var a="geid_"+ft()+"_",u=0;return R(l(t),"_attributes",{}),R(l(t),"_nodes",new Map),R(l(t),"_edges",new Map),R(l(t),"_directedSize",0),R(l(t),"_undirectedSize",0),R(l(t),"_directedSelfLoopCount",0),R(l(t),"_undirectedSelfLoopCount",0),R(l(t),"_edgeKeyGenerator",function(){var s;do{s=a+u++}while(t._edges.has(s));return s}),R(l(t),"_options",e),ze.forEach(function(s){return R(l(t),s,t[s])}),V(l(t),"order",function(){return t._nodes.size}),V(l(t),"size",function(){return t._edges.size}),V(l(t),"directedSize",function(){return t._directedSize}),V(l(t),"undirectedSize",function(){return t._undirectedSize}),V(l(t),"selfLoopCount",function(){return t._directedSelfLoopCount+t._undirectedSelfLoopCount}),V(l(t),"directedSelfLoopCount",function(){return t._directedSelfLoopCount}),V(l(t),"undirectedSelfLoopCount",function(){return t._undirectedSelfLoopCount}),V(l(t),"multi",t._options.multi),V(l(t),"type",t._options.type),V(l(t),"allowSelfLoops",t._options.allowSelfLoops),V(l(t),"implementation",function(){return"graphology"}),t}v(o,n);var i=o.prototype;return i._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},i.hasNode=function(e){return this._nodes.has(""+e)},i.hasDirectedEdge=function(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){var a=this._edges.get(""+e);return!!a&&!a.undirected}if(2===arguments.length){t=""+t;var u=this._nodes.get(e=""+e);if(!u)return!1;var s=u.out[t];return!(!s||this.multi&&!s.size)}throw new y("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasUndirectedEdge=function(e,t){if("directed"===this.type)return!1;if(1===arguments.length){var a=this._edges.get(""+e);return!!a&&a.undirected}if(2===arguments.length){t=""+t;var u=this._nodes.get(e=""+e);if(!u)return!1;var s=u.undirected[t];return!(!s||this.multi&&!s.size)}throw new y("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasEdge=function(e,t){if(1===arguments.length)return this._edges.has(""+e);if(2===arguments.length){t=""+t;var a=this._nodes.get(e=""+e);if(!a)return!1;var u=void 0!==a.out&&a.out[t];return u||(u=void 0!==a.undirected&&a.undirected[t]),!(!u||this.multi&&!u.size)}throw new y("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.directedEdge=function(e,t){if("undirected"!==this.type){if(e=""+e,t=""+t,this.multi)throw new G("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var r=this._nodes.get(e);if(!r)throw new f('Graph.directedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.directedEdge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.out&&r.out[t]||void 0;return a?a.key:void 0}},i.undirectedEdge=function(e,t){if("directed"!==this.type){if(e=""+e,t=""+t,this.multi)throw new G("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var r=this._nodes.get(e);if(!r)throw new f('Graph.undirectedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.undirectedEdge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.undirected&&r.undirected[t]||void 0;return a?a.key:void 0}},i.edge=function(e,t){if(this.multi)throw new G("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.edge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.edge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(a)return a.key},i.areDirectedNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areDirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in r.in||t in r.out)},i.areOutNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areOutNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.out},i.areInNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areInNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.in},i.areUndirectedNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areUndirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"directed"!==this.type&&t in r.undirected},i.areNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in r.in||t in r.out)||"directed"!==this.type&&t in r.undirected},i.areInboundNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areInboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.in||"directed"!==this.type&&t in r.undirected},i.areOutboundNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areOutboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.out||"directed"!==this.type&&t in r.undirected},i.inDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree},i.outDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.outDegree},i.directedDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.directedDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree+t.outDegree},i.undirectedDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.undirectedDegree: could not find the "'.concat(e,'" node in the graph.'));return"directed"===this.type?0:t.undirectedDegree},i.inboundDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inboundDegree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree),r},i.outboundDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outboundDegree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.outDegree),r},i.degree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.degree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree),r},i.inDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.in[e];return t.inDegree-(r?this.multi?r.size:1:0)},i.outDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.out[e];return t.outDegree-(r?this.multi?r.size:1:0)},i.directedDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.out[e];return t.inDegree+t.outDegree-2*(r?this.multi?r.size:1:0)},i.undirectedDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("directed"===this.type)return 0;var r=t.undirected[e];return t.undirectedDegree-2*(r?this.multi?r.size:1:0)},i.inboundDegreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,u=0;return"directed"!==this.type&&(a+=r.undirectedDegree,u+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.inDegree,u+=(t=r.out[e])?this.multi?t.size:1:0),a-u},i.outboundDegreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,u=0;return"directed"!==this.type&&(a+=r.undirectedDegree,u+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.outDegree,u+=(t=r.in[e])?this.multi?t.size:1:0),a-u},i.degreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.degreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,u=0;return"directed"!==this.type&&(a+=r.undirectedDegree,u+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.inDegree+r.outDegree,u+=2*((t=r.out[e])?this.multi?t.size:1:0)),a-u},i.source=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.source: could not find the "'.concat(e,'" edge in the graph.'));return t.source.key},i.target=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.target: could not find the "'.concat(e,'" edge in the graph.'));return t.target.key},i.extremities=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.extremities: could not find the "'.concat(e,'" edge in the graph.'));return[t.source.key,t.target.key]},i.opposite=function(e,t){e=""+e;var r=this._edges.get(t=""+t);if(!r)throw new f('Graph.opposite: could not find the "'.concat(t,'" edge in the graph.'));var a=r.source.key,u=r.target.key;if(e===a)return u;if(e===u)return a;throw new f('Graph.opposite: the "'.concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(a,", ").concat(u,")."))},i.hasExtremity=function(e,t){t=""+t;var r=this._edges.get(e=""+e);if(!r)throw new f('Graph.hasExtremity: could not find the "'.concat(e,'" edge in the graph.'));return r.source.key===t||r.target.key===t},i.isUndirected=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isUndirected: could not find the "'.concat(e,'" edge in the graph.'));return t.undirected},i.isDirected=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isDirected: could not find the "'.concat(e,'" edge in the graph.'));return!t.undirected},i.isSelfLoop=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isSelfLoop: could not find the "'.concat(e,'" edge in the graph.'));return t.source===t.target},i.addNode=function(e,t){return function(a,u,s){if(s&&!S(s))throw new y('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(s,'"'));if(s=s||{},a._nodes.has(u=""+u))throw new G('Graph.addNode: the "'.concat(u,'" node already exist in the graph.'));var c=new a.NodeDataClass(u,s);return a._nodes.set(u,c),a.emit("nodeAdded",{key:u,attributes:s}),c}(this,e,t).key},i.mergeNode=function(e,t){if(t&&!S(t))throw new y('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(t,'"'));t=t||{};var r=this._nodes.get(e=""+e);return r?(t&&(w(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])},i.updateNode=function(e,t){if(t&&"function"!=typeof t)throw new y('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(t,'"'));var r=this._nodes.get(e=""+e);if(r)return t&&(r.attributes=t(r.attributes),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})),[e,!1];var u=t?t({}):{};return r=new this.NodeDataClass(e,u),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:u}),[e,!0]},i.dropNode=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.dropNode: could not find the "'.concat(e,'" node in the graph.'));if("undirected"!==this.type){for(var a in r.out){t=r.out[a];do{he(this,t),t=t.next}while(t)}for(var u in r.in){t=r.in[u];do{he(this,t),t=t.next}while(t)}}if("directed"!==this.type)for(var s in r.undirected){t=r.undirected[s];do{he(this,t),t=t.next}while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:r.attributes})},i.dropEdge=function(e){var t;if(arguments.length>1){var r=""+arguments[0],a=""+arguments[1];if(!(t=K(this,r,a,this.type)))throw new f('Graph.dropEdge: could not find the "'.concat(r,'" -> "').concat(a,'" edge in the graph.'))}else if(!(t=this._edges.get(e=""+e)))throw new f('Graph.dropEdge: could not find the "'.concat(e,'" edge in the graph.'));return he(this,t),this},i.dropDirectedEdge=function(e,t){if(arguments.length<2)throw new G("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=K(this,e=""+e,t=""+t,"directed");if(!r)throw new f('Graph.dropDirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return he(this,r),this},i.dropUndirectedEdge=function(e,t){if(arguments.length<2)throw new G("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new G("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=K(this,e,t,"undirected");if(!r)throw new f('Graph.dropUndirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return he(this,r),this},i.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},i.clearEdges=function(){for(var e,t=this._nodes.values();!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},i.getAttribute=function(e){return this._attributes[e]},i.getAttributes=function(){return this._attributes},i.hasAttribute=function(e){return this._attributes.hasOwnProperty(e)},i.setAttribute=function(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},i.updateAttribute=function(e,t){if("function"!=typeof t)throw new y("Graph.updateAttribute: updater should be a function.");return this._attributes[e]=t(this._attributes[e]),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},i.removeAttribute=function(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this},i.replaceAttributes=function(e){if(!S(e))throw new y("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},i.mergeAttributes=function(e){if(!S(e))throw new y("Graph.mergeAttributes: provided attributes are not a plain object.");return w(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this},i.updateAttributes=function(e){if("function"!=typeof e)throw new y("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},i.updateEachNodeAttributes=function(e,t){if("function"!=typeof e)throw new y("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!F(t))throw new y("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var r,a,u=this._nodes.values();!0!==(r=u.next()).done;)(a=r.value).attributes=e(a.key,a.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})},i.updateEachEdgeAttributes=function(e,t){if("function"!=typeof e)throw new y("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!F(t))throw new y("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var r,a,u,s,c=this._edges.values();!0!==(r=c.next()).done;)u=(a=r.value).source,a.attributes=e(a.key,a.attributes,u.key,(s=a.target).key,u.attributes,s.attributes,a.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})},i.forEachAdjacencyEntry=function(e){if("function"!=typeof e)throw new y("Graph.forEachAdjacencyEntry: expecting a callback.");me(!1,!1,!1,this,e)},i.forEachAdjacencyEntryWithOrphans=function(e){if("function"!=typeof e)throw new y("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");me(!1,!1,!0,this,e)},i.forEachAssymetricAdjacencyEntry=function(e){if("function"!=typeof e)throw new y("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");me(!1,!0,!1,this,e)},i.forEachAssymetricAdjacencyEntryWithOrphans=function(e){if("function"!=typeof e)throw new y("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");me(!1,!0,!0,this,e)},i.nodes=function(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):Se(this._nodes.keys(),this._nodes.size)},i.forEachNode=function(e){if("function"!=typeof e)throw new y("Graph.forEachNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)e((r=t.value).key,r.attributes)},i.findNode=function(e){if("function"!=typeof e)throw new y("Graph.findNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(e((r=t.value).key,r.attributes))return r.key},i.mapNodes=function(e){if("function"!=typeof e)throw new y("Graph.mapNode: expecting a callback.");for(var t,r,a=this._nodes.values(),u=new Array(this.order),s=0;!0!==(t=a.next()).done;)u[s++]=e((r=t.value).key,r.attributes);return u},i.someNode=function(e){if("function"!=typeof e)throw new y("Graph.someNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(e((r=t.value).key,r.attributes))return!0;return!1},i.everyNode=function(e){if("function"!=typeof e)throw new y("Graph.everyNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(!e((r=t.value).key,r.attributes))return!1;return!0},i.filterNodes=function(e){if("function"!=typeof e)throw new y("Graph.filterNodes: expecting a callback.");for(var t,r,a=this._nodes.values(),u=[];!0!==(t=a.next()).done;)e((r=t.value).key,r.attributes)&&u.push(r.key);return u},i.reduceNodes=function(e,t){if("function"!=typeof e)throw new y("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new y("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var r,a,u=t,s=this._nodes.values();!0!==(r=s.next()).done;)u=e(u,(a=r.value).key,a.attributes);return u},i.nodeEntries=function(){var e=this._nodes.values();return new $(function(){var t=e.next();if(t.done)return t;var r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})},i.export=function(){var e=new Array(this._nodes.size),t=0;this._nodes.forEach(function(a,u){var c,h;e[t++]=(h={key:u},I((c=a).attributes)||(h.attributes=w({},c.attributes)),h)});var r=new Array(this._edges.size);return t=0,this._edges.forEach(function(a,u){var c,h;r[t++]=(h={key:u,source:(c=a).source.key,target:c.target.key},I(c.attributes)||(h.attributes=w({},c.attributes)),c.undirected&&(h.undirected=!0),h)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}},i.import=function(e){var t,r,a,u,s,c=this,h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(M(e))return e.forEachNode(function(J,ee){h?c.mergeNode(J,ee):c.addNode(J,ee)}),e.forEachEdge(function(J,ee,ue,ve,yt,mt,Ie){h?Ie?c.mergeUndirectedEdgeWithKey(J,ue,ve,ee):c.mergeDirectedEdgeWithKey(J,ue,ve,ee):Ie?c.addUndirectedEdgeWithKey(J,ue,ve,ee):c.addDirectedEdgeWithKey(J,ue,ve,ee)}),this;if(!S(e))throw new y("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!S(e.attributes))throw new y("Graph.import: invalid attributes. Expecting a plain object.");h?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(a=e.nodes,!Array.isArray(a))throw new y("Graph.import: invalid nodes. Expecting an array.");for(t=0,r=a.length;t<r;t++){dt(u=a[t]);var g=u.key,p=u.attributes;h?this.mergeNode(g,p):this.addNode(g,p)}}if(e.edges){if(a=e.edges,!Array.isArray(a))throw new y("Graph.import: invalid edges. Expecting an array.");for(t=0,r=a.length;t<r;t++){ht(s=a[t]);var j=s.source,P=s.target,X=s.attributes,Y=s.undirected,Q=void 0!==Y&&Y;"key"in s?(h?Q?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:Q?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,s.key,j,P,X):(h?Q?this.mergeUndirectedEdge:this.mergeDirectedEdge:Q?this.addUndirectedEdge:this.addDirectedEdge).call(this,j,P,X)}}return this},i.nullCopy=function(e){var t=new o(w({},this._options,e));return t.replaceAttributes(w({},this.getAttributes())),t},i.emptyCopy=function(e){var t=this.nullCopy(e);return this._nodes.forEach(function(r,a){var u=w({},r.attributes);r=new t.NodeDataClass(a,u),t._nodes.set(a,r)}),t},i.copy=function(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new G('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(e.type,'" because this would mean losing information about the current graph.'));if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new G("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new G("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var t,r,a=this.emptyCopy(e),u=this._edges.values();!0!==(t=u.next()).done;)Me(a,"copy",!1,(r=t.value).undirected,r.key,r.source.key,r.target.key,w({},r.attributes));return a},i.toJSON=function(){return this.export()},i.toString=function(){return"[object Graph]"},i.inspect=function(){var e=this,t={};this._nodes.forEach(function(c,h){t[h]=c.attributes});var r={},a={};this._edges.forEach(function(c,h){var d,g=c.undirected?"--":"->",p="",k=c.source.key,j=c.target.key;c.undirected&&k>j&&(d=k,k=j,j=d);var P="(".concat(k,")").concat(g,"(").concat(j,")");h.startsWith("geid_")?e.multi&&(void 0===a[P]?a[P]=0:a[P]++,p+="".concat(a[P],". ")):p+="[".concat(h,"]: "),r[p+=P]=c.attributes});var u={};for(var s in this)this.hasOwnProperty(s)&&!ze.has(s)&&"function"!=typeof this[s]&&"symbol"!==N(s)&&(u[s]=this[s]);return u.attributes=this._attributes,u.nodes=t,u.edges=r,R(u,"constructor",this.constructor),u},o}(U.exports.EventEmitter);typeof Symbol<"u"&&(W.prototype[Symbol.for("nodejs.util.inspect.custom")]=W.prototype.inspect),[{name:function(n){return"".concat(n,"Edge")},generateKey:!0},{name:function(n){return"".concat(n,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(n){return"".concat(n,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(n){return"".concat(n,"EdgeWithKey")}},{name:function(n){return"".concat(n,"DirectedEdgeWithKey")},type:"directed"},{name:function(n){return"".concat(n,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(n){["add","merge","update"].forEach(function(o){var i=n.name(o),e="add"===o?Me:gt;W.prototype[i]=n.generateKey?function(t,r,a){return e(this,i,!0,"undirected"===(n.type||this.type),null,t,r,a,"update"===o)}:function(t,r,a,u){return e(this,i,!1,"undirected"===(n.type||this.type),t,r,a,u,"update"===o)}})}),n=W,Ve.forEach(function(o){var i=o.name,e=o.attacher;e(n,i("Node"),0),e(n,i("Source"),1),e(n,i("Target"),2),e(n,i("Opposite"),3)}),function(n){$e.forEach(function(o){var i=o.name,e=o.attacher;e(n,i("Edge"),"mixed"),e(n,i("DirectedEdge"),"directed"),e(n,i("UndirectedEdge"),"undirected")})}(W),function(n){Je.forEach(function(o){var e,t,r,a;r=(e=o).type,a=e.direction,n.prototype[t=e.name]=function(u,s){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return tt(this,r);if(1===arguments.length){var c=this._nodes.get(u=""+u);if(void 0===c)throw new f("Graph.".concat(t,': could not find the "').concat(u,'" node in the graph.'));return rt(this.multi,"mixed"===r?this.type:r,a,c)}if(2===arguments.length){s=""+s;var h=this._nodes.get(u=""+u);if(!h)throw new f("Graph.".concat(t,':  could not find the "').concat(u,'" source node in the graph.'));if(!this._nodes.has(s))throw new f("Graph.".concat(t,':  could not find the "').concat(s,'" target node in the graph.'));return ot(r,this.multi,a,h,s)}throw new y("Graph.".concat(t,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))},function(i,e){var t=e.name,r=e.type,a=e.direction,u="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[u]=function(d,g,p){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return Ne(!1,this,r,p=d);if(2===arguments.length){p=g;var k=this._nodes.get(d=""+d);if(void 0===k)throw new f("Graph.".concat(u,': could not find the "').concat(d,'" node in the graph.'));return Ee(!1,this.multi,"mixed"===r?this.type:r,a,k,p)}if(3===arguments.length){g=""+g;var j=this._nodes.get(d=""+d);if(!j)throw new f("Graph.".concat(u,':  could not find the "').concat(d,'" source node in the graph.'));if(!this._nodes.has(g))throw new f("Graph.".concat(u,':  could not find the "').concat(g,'" target node in the graph.'));return Ge(!1,r,this.multi,a,j,g,p)}throw new y("Graph.".concat(u,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var s="map"+t[0].toUpperCase()+t.slice(1);i.prototype[s]=function(){var d,g=Array.prototype.slice.call(arguments),p=g.pop();if(0===g.length){var k=0;"directed"!==r&&(k+=this.undirectedSize),"undirected"!==r&&(k+=this.directedSize),d=new Array(k);var j=0;g.push(function(P,X,Y,Q,J,ee,ue){d[j++]=p(P,X,Y,Q,J,ee,ue)})}else d=[],g.push(function(P,X,Y,Q,J,ee,ue){d.push(p(P,X,Y,Q,J,ee,ue))});return this[u].apply(this,g),d};var c="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(){var d=Array.prototype.slice.call(arguments),g=d.pop(),p=[];return d.push(function(k,j,P,X,Y,Q,J){g(k,j,P,X,Y,Q,J)&&p.push(k)}),this[u].apply(this,d),p};var h="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[h]=function(){var d,g,p=Array.prototype.slice.call(arguments);if(p.length<2||p.length>4)throw new y("Graph.".concat(h,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(p.length,")."));if("function"==typeof p[p.length-1]&&"function"!=typeof p[p.length-2])throw new y("Graph.".concat(h,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));2===p.length?(d=p[0],g=p[1],p=[]):3===p.length?(d=p[1],g=p[2],p=[p[0]]):4===p.length&&(d=p[2],g=p[3],p=[p[0],p[1]]);var k=g;return p.push(function(j,P,X,Y,Q,J,ee){k=d(k,j,P,X,Y,Q,J,ee)}),this[u].apply(this,p),k}}(n,o),function(i,e){var t=e.name,r=e.type,a=e.direction,u="find"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[u]=function(h,d,g){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return!1;if(1===arguments.length)return Ne(!0,this,r,g=h);if(2===arguments.length){g=d;var p=this._nodes.get(h=""+h);if(void 0===p)throw new f("Graph.".concat(u,': could not find the "').concat(h,'" node in the graph.'));return Ee(!0,this.multi,"mixed"===r?this.type:r,a,p,g)}if(3===arguments.length){d=""+d;var k=this._nodes.get(h=""+h);if(!k)throw new f("Graph.".concat(u,':  could not find the "').concat(h,'" source node in the graph.'));if(!this._nodes.has(d))throw new f("Graph.".concat(u,':  could not find the "').concat(d,'" target node in the graph.'));return Ge(!0,r,this.multi,a,k,d,g)}throw new y("Graph.".concat(u,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var s="some"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(){var h=Array.prototype.slice.call(arguments),d=h.pop();return h.push(function(g,p,k,j,P,X,Y){return d(g,p,k,j,P,X,Y)}),!!this[u].apply(this,h)};var c="every"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[c]=function(){var h=Array.prototype.slice.call(arguments),d=h.pop();return h.push(function(g,p,k,j,P,X,Y){return!d(g,p,k,j,P,X,Y)}),!this[u].apply(this,h)}}(n,o),function(i,e){var r=e.type,a=e.direction,u=e.name.slice(0,-1)+"Entries";i.prototype[u]=function(s,c){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return $.empty();if(!arguments.length)return nt(this,r);if(1===arguments.length){var h=this._nodes.get(s=""+s);if(!h)throw new f("Graph.".concat(u,': could not find the "').concat(s,'" node in the graph.'));return it(r,a,h)}if(2===arguments.length){c=""+c;var d=this._nodes.get(s=""+s);if(!d)throw new f("Graph.".concat(u,':  could not find the "').concat(s,'" source node in the graph.'));if(!this._nodes.has(c))throw new f("Graph.".concat(u,':  could not find the "').concat(c,'" target node in the graph.'));return at(r,a,d,c)}throw new y("Graph.".concat(u,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(n,o)})}(W),function(n){ut.forEach(function(o){var i,e,t,r,a,u,s;(function st(n,o){var i=o.name,e=o.type,t=o.direction;n.prototype[i]=function(r){if("mixed"!==e&&"mixed"!==this.type&&e!==this.type)return[];var a=this._nodes.get(r=""+r);if(void 0===a)throw new f("Graph.".concat(i,': could not find the "').concat(r,'" node in the graph.'));return function(u,s,c){if("mixed"!==u){if("undirected"===u)return Object.keys(c.undirected);if("string"==typeof s)return Object.keys(c[s])}var h=[];return xe(!1,u,s,c,function(d){h.push(d)}),h}("mixed"===e?this.type:e,t,a)}})(n,o),function(i,e){var t=e.name,r=e.type,a=e.direction,u="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[u]=function(d,g){if("mixed"===r||"mixed"===this.type||r===this.type){var p=this._nodes.get(d=""+d);if(void 0===p)throw new f("Graph.".concat(u,': could not find the "').concat(d,'" node in the graph.'));xe(!1,"mixed"===r?this.type:r,a,p,g)}};var s="map"+t[0].toUpperCase()+t.slice(1);i.prototype[s]=function(d,g){var p=[];return this[u](d,function(k,j){p.push(g(k,j))}),p};var c="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(d,g){var p=[];return this[u](d,function(k,j){g(k,j)&&p.push(k)}),p};var h="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[h]=function(d,g,p){if(arguments.length<3)throw new y("Graph.".concat(h,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var k=p;return this[u](d,function(j,P){k=g(k,j,P)}),k}}(n,o),i=n,r=(e=o).type,a=e.direction,u=(t=e.name)[0].toUpperCase()+t.slice(1,-1),i.prototype[s="find"+u]=function(d,g){if("mixed"===r||"mixed"===this.type||r===this.type){var p=this._nodes.get(d=""+d);if(void 0===p)throw new f("Graph.".concat(s,': could not find the "').concat(d,'" node in the graph.'));return xe(!0,"mixed"===r?this.type:r,a,p,g)}},i.prototype["some"+u]=function(d,g){return!!this[s](d,g)},i.prototype["every"+u]=function(d,g){return!this[s](d,function(p,k){return!g(p,k)})},function ct(n,o){var e=o.type,t=o.direction,r=o.name.slice(0,-1)+"Entries";n.prototype[r]=function(a){if("mixed"!==e&&"mixed"!==this.type&&e!==this.type)return $.empty();var u=this._nodes.get(a=""+a);if(void 0===u)throw new f("Graph.".concat(r,': could not find the "').concat(a,'" node in the graph.'));return function(s,c,h){if("mixed"!==s){if("undirected"===s)return ge(null,h,h.undirected);if("string"==typeof c)return ge(null,h,h[c])}var d=$.empty(),g=new ye;return"undirected"!==s&&("out"!==c&&(d=ie(d,ge(g,h,h.in))),"in"!==c&&(d=ie(d,ge(g,h,h.out)))),"directed"!==s&&(d=ie(d,ge(g,h,h.undirected))),d}("mixed"===e?this.type:e,t,u)}}(n,o)})}(W);var We=function(n){function o(i){var e=w({type:"directed"},i);if("multi"in e&&!1!==e.multi)throw new y("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==e.type)throw new y('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return v(o,n),o}(W),Pe=function(n){function o(i){var e=w({type:"undirected"},i);if("multi"in e&&!1!==e.multi)throw new y("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==e.type)throw new y('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return v(o,n),o}(W),Ke=function(n){function o(i){var e=w({multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return n.call(this,e)||this}return v(o,n),o}(W),Re=function(n){function o(i){var e=w({type:"directed",multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==e.type)throw new y('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return v(o,n),o}(W),Be=function(n){function o(i){var e=w({type:"undirected",multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==e.type)throw new y('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return v(o,n),o}(W);function fe(n){n.from=function(o,i){var e=w({},o.options,i),t=new n(e);return t.import(o),t}}return fe(W),fe(We),fe(Pe),fe(Ke),fe(Re),fe(Be),W.Graph=W,W.DirectedGraph=We,W.UndirectedGraph=Pe,W.MultiGraph=Ke,W.MultiDirectedGraph=Re,W.MultiUndirectedGraph=Be,W.InvalidArgumentsGraphError=y,W.NotFoundGraphError=f,W.UsageGraphError=G,W}()}}]);