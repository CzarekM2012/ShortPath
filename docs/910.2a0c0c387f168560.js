(()=>{var Ye={5149:(Q,W,E)=>{var N=E(6714),V=E(6262).B,L=E(778).De,O=E(3882);W.dQ=function _(g){var U=function K(g){if(!N(g))throw new Error("graphology-components: the given graph is not a valid graphology instance.");if(!g.order)return[];var j,U=new O(g),v=U.push.bind(U),x=[];return U.forEachNodeYetUnseen(function(A){j=[],U.push(A);for(var C;0!==U.size;)C=U.pop(),j.push(C),g.forEachNeighbor(C,v);return j.length>x.length&&(x=j),x.length>U.countUnseenNodes()}),x}(g),v=g.nullCopy();return U.forEach(function(x){V(v,x,g.getNodeAttributes(x))}),g.forEachEdge(function(x,j,A,C,J,H,X){v.hasNode(A)&&L(v,X,x,A,C,j)}),v}},3882:Q=>{function W(E){this.graph=E,this.stack=new Array(E.order),this.seen=new Set,this.size=0}W.prototype.hasAlreadySeenEverything=function(){return this.seen.size===this.graph.order},W.prototype.countUnseenNodes=function(){return this.graph.order-this.seen.size},W.prototype.forEachNodeYetUnseen=function(E){var P=this.seen,N=this.graph;N.someNode(function(V,L){return P.size===N.order||!P.has(V)&&!!E(V,L)})},W.prototype.has=function(E){return this.seen.has(E)},W.prototype.push=function(E){var P=this.seen.size;return this.seen.add(E),P!==this.seen.size&&(this.stack[this.size++]=E,!0)},W.prototype.pushWith=function(E,P){var N=this.seen.size;return this.seen.add(E),N!==this.seen.size&&(this.stack[this.size++]=P,!0)},W.prototype.pop=function(){if(0!==this.size)return this.stack[--this.size]},Q.exports=W},778:(Q,W)=>{W.De=function(N,V,L,O,m,G){return G=Object.assign({},G),V?null==L?N.addUndirectedEdge(O,m,G):N.addUndirectedEdgeWithKey(L,O,m,G):null==L?N.addDirectedEdge(O,m,G):N.addDirectedEdgeWithKey(L,O,m,G)}},6262:(Q,W)=>{W.B=function(E,P,N){return N=Object.assign({},N),E.addNode(P,N)}},6714:Q=>{Q.exports=function(E){return null!==E&&"object"==typeof E&&"function"==typeof E.addUndirectedEdgeWithKey&&"function"==typeof E.dropNode&&"boolean"==typeof E.multi}},5595:function(Q){Q.exports=function(){"use strict";function W(n){return(W="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(o){return typeof o}:function(o){return o&&"function"==typeof Symbol&&o.constructor===Symbol&&o!==Symbol.prototype?"symbol":typeof o})(n)}function E(n,o){n.prototype=Object.create(o.prototype),n.prototype.constructor=n,N(n,o)}function P(n){return(P=Object.setPrototypeOf?Object.getPrototypeOf:function(o){return o.__proto__||Object.getPrototypeOf(o)})(n)}function N(n,o){return(N=Object.setPrototypeOf||function(i,e){return i.__proto__=e,i})(n,o)}function V(){if(typeof Reflect>"u"||!Reflect.construct||Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Boolean.prototype.valueOf.call(Reflect.construct(Boolean,[],function(){})),!0}catch{return!1}}function L(n,o,i){return(L=V()?Reflect.construct:function(e,t,r){var a=[null];a.push.apply(a,t);var s=new(Function.bind.apply(e,a));return r&&N(s,r.prototype),s}).apply(null,arguments)}function O(n){var o="function"==typeof Map?new Map:void 0;return O=function(i){if(null===i||-1===Function.toString.call(i).indexOf("[native code]"))return i;if("function"!=typeof i)throw new TypeError("Super expression must either be null or a function");if(void 0!==o){if(o.has(i))return o.get(i);o.set(i,t)}function t(){return L(i,arguments,P(this).constructor)}return t.prototype=Object.create(i.prototype,{constructor:{value:t,enumerable:!1,writable:!0,configurable:!0}}),N(t,i)},O(n)}function m(n){if(void 0===n)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return n}var G=function(){for(var n=arguments[0],o=1,i=arguments.length;o<i;o++)if(arguments[o])for(var e in arguments[o])n[e]=arguments[o][e];return n};function z(n,o,i,e){var t=n._nodes.get(o),r=null;return t?r="mixed"===e?t.out&&t.out[i]||t.undirected&&t.undirected[i]:"directed"===e?t.out&&t.out[i]:t.undirected&&t.undirected[i]:r}function D(n){return null!==n&&"object"===W(n)&&"function"==typeof n.addUndirectedEdgeWithKey&&"function"==typeof n.dropNode}function b(n){return"object"===W(n)&&null!==n&&n.constructor===Object}function K(n){var o;for(o in n)return!1;return!0}function _(n,o,i){Object.defineProperty(n,o,{enumerable:!1,configurable:!1,writable:!0,value:i})}function w(n,o,i){var e={enumerable:!0,configurable:!0};"function"==typeof i?e.get=i:(e.value=i,e.writable=!1),Object.defineProperty(n,o,e)}function R(n){return!(!b(n)||n.attributes&&!Array.isArray(n.attributes))}"function"==typeof Object.assign&&(G=Object.assign);var g,U={exports:{}},v="object"==typeof Reflect?Reflect:null,x=v&&"function"==typeof v.apply?v.apply:function(n,o,i){return Function.prototype.apply.call(n,o,i)};g=v&&"function"==typeof v.ownKeys?v.ownKeys:Object.getOwnPropertySymbols?function(n){return Object.getOwnPropertyNames(n).concat(Object.getOwnPropertySymbols(n))}:function(n){return Object.getOwnPropertyNames(n)};var j=Number.isNaN||function(n){return n!=n};function A(){A.init.call(this)}U.exports=A,U.exports.once=function(n,o){return new Promise(function(i,e){function t(a){n.removeListener(o,r),e(a)}function r(){"function"==typeof n.removeListener&&n.removeListener("error",t),i([].slice.call(arguments))}var a;ae(n,o,r,{once:!0}),"error"!==o&&("function"==typeof(a=n).on&&ae(a,"error",t,{once:!0}))})},A.EventEmitter=A,A.prototype._events=void 0,A.prototype._eventsCount=0,A.prototype._maxListeners=void 0;var C=10;function J(n){if("function"!=typeof n)throw new TypeError('The "listener" argument must be of type Function. Received type '+typeof n)}function H(n){return void 0===n._maxListeners?A.defaultMaxListeners:n._maxListeners}function X(n,o,i,e){var t,r,a;if(J(i),void 0===(r=n._events)?(r=n._events=Object.create(null),n._eventsCount=0):(void 0!==r.newListener&&(n.emit("newListener",o,i.listener?i.listener:i),r=n._events),a=r[o]),void 0===a)a=r[o]=i,++n._eventsCount;else if("function"==typeof a?a=r[o]=e?[i,a]:[a,i]:e?a.unshift(i):a.push(i),(t=H(n))>0&&a.length>t&&!a.warned){a.warned=!0;var u=new Error("Possible EventEmitter memory leak detected. "+a.length+" "+String(o)+" listeners added. Use emitter.setMaxListeners() to increase limit");u.name="MaxListenersExceededWarning",u.emitter=n,u.type=o,u.count=a.length,console&&console.warn&&console.warn(u)}return n}function ue(){if(!this.fired)return this.target.removeListener(this.type,this.wrapFn),this.fired=!0,0===arguments.length?this.listener.call(this.target):this.listener.apply(this.target,arguments)}function te(n,o,i){var e={fired:!1,wrapFn:void 0,target:n,type:o,listener:i},t=ue.bind(e);return t.listener=i,e.wrapFn=t,t}function oe(n,o,i){var e=n._events;if(void 0===e)return[];var t=e[o];return void 0===t?[]:"function"==typeof t?i?[t.listener||t]:[t]:i?function(r){for(var a=new Array(r.length),s=0;s<a.length;++s)a[s]=r[s].listener||r[s];return a}(t):ne(t,t.length)}function pe(n){var o=this._events;if(void 0!==o){var i=o[n];if("function"==typeof i)return 1;if(void 0!==i)return i.length}return 0}function ne(n,o){for(var i=new Array(o),e=0;e<o;++e)i[e]=n[e];return i}function ae(n,o,i,e){if("function"==typeof n.on)e.once?n.once(o,i):n.on(o,i);else{if("function"!=typeof n.addEventListener)throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type '+typeof n);n.addEventListener(o,function t(r){e.once&&n.removeEventListener(o,t),i(r)})}}function Z(n){if("function"!=typeof n)throw new Error("obliterator/iterator: expecting a function!");this.next=n}Object.defineProperty(A,"defaultMaxListeners",{enumerable:!0,get:function(){return C},set:function(n){if("number"!=typeof n||n<0||j(n))throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received '+n+".");C=n}}),A.init=function(){void 0!==this._events&&this._events!==Object.getPrototypeOf(this)._events||(this._events=Object.create(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0},A.prototype.setMaxListeners=function(n){if("number"!=typeof n||n<0||j(n))throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received '+n+".");return this._maxListeners=n,this},A.prototype.getMaxListeners=function(){return H(this)},A.prototype.emit=function(n){for(var o=[],i=1;i<arguments.length;i++)o.push(arguments[i]);var e="error"===n,t=this._events;if(void 0!==t)e=e&&void 0===t.error;else if(!e)return!1;if(e){var r;if(o.length>0&&(r=o[0]),r instanceof Error)throw r;var a=new Error("Unhandled error."+(r?" ("+r.message+")":""));throw a.context=r,a}var s=t[n];if(void 0===s)return!1;if("function"==typeof s)x(s,this,o);else{var u=s.length,c=ne(s,u);for(i=0;i<u;++i)x(c[i],this,o)}return!0},A.prototype.on=A.prototype.addListener=function(n,o){return X(this,n,o,!1)},A.prototype.prependListener=function(n,o){return X(this,n,o,!0)},A.prototype.once=function(n,o){return J(o),this.on(n,te(this,n,o)),this},A.prototype.prependOnceListener=function(n,o){return J(o),this.prependListener(n,te(this,n,o)),this},A.prototype.off=A.prototype.removeListener=function(n,o){var i,e,t,r,a;if(J(o),void 0===(e=this._events))return this;if(void 0===(i=e[n]))return this;if(i===o||i.listener===o)0==--this._eventsCount?this._events=Object.create(null):(delete e[n],e.removeListener&&this.emit("removeListener",n,i.listener||o));else if("function"!=typeof i){for(t=-1,r=i.length-1;r>=0;r--)if(i[r]===o||i[r].listener===o){a=i[r].listener,t=r;break}if(t<0)return this;0===t?i.shift():function(s,u){for(;u+1<s.length;u++)s[u]=s[u+1];s.pop()}(i,t),1===i.length&&(e[n]=i[0]),void 0!==e.removeListener&&this.emit("removeListener",n,a||o)}return this},A.prototype.removeAllListeners=function(n){var o,i,e;if(void 0===(i=this._events))return this;if(void 0===i.removeListener)return 0===arguments.length?(this._events=Object.create(null),this._eventsCount=0):void 0!==i[n]&&(0==--this._eventsCount?this._events=Object.create(null):delete i[n]),this;if(0===arguments.length){var t,r=Object.keys(i);for(e=0;e<r.length;++e)"removeListener"!==(t=r[e])&&this.removeAllListeners(t);return this.removeAllListeners("removeListener"),this._events=Object.create(null),this._eventsCount=0,this}if("function"==typeof(o=i[n]))this.removeListener(n,o);else if(void 0!==o)for(e=o.length-1;e>=0;e--)this.removeListener(n,o[e]);return this},A.prototype.listeners=function(n){return oe(this,n,!0)},A.prototype.rawListeners=function(n){return oe(this,n,!1)},A.listenerCount=function(n,o){return"function"==typeof n.listenerCount?n.listenerCount(o):pe.call(n,o)},A.prototype.listenerCount=pe,A.prototype.eventNames=function(){return this._eventsCount>0?g(this._events):[]},typeof Symbol<"u"&&(Z.prototype[Symbol.iterator]=function(){return this}),Z.of=function(){var n=arguments,o=n.length,i=0;return new Z(function(){return i>=o?{done:!0}:{done:!1,value:n[i++]}})},Z.empty=function(){return new Z(function(){return{done:!0}})},Z.fromSequence=function(n){var o=0,i=n.length;return new Z(function(){return o>=i?{done:!0}:{done:!1,value:n[o++]}})},Z.is=function(n){return n instanceof Z||"object"==typeof n&&null!==n&&"function"==typeof n.next};var T=Z,ce={};ce.ARRAY_BUFFER_SUPPORT=typeof ArrayBuffer<"u",ce.SYMBOL_SUPPORT=typeof Symbol<"u";var be=T,Ve=ce.ARRAY_BUFFER_SUPPORT,$e=ce.SYMBOL_SUPPORT,Ne=function(n){var i,o="string"==typeof(i=n)||Array.isArray(i)||Ve&&ArrayBuffer.isView(i)?be.fromSequence(i):"object"!=typeof i||null===i?null:$e&&"function"==typeof i[Symbol.iterator]?i[Symbol.iterator]():"function"==typeof i.next?i:null;if(!o)throw new Error("obliterator: target is not iterable nor a valid iterator.");return o},qe=Ne,Ue=function(n,o){for(var i,e=arguments.length>1?o:1/0,t=e!==1/0?new Array(e):[],r=0,a=qe(n);;){if(r===e)return t;if((i=a.next()).done)return r!==o&&(t.length=r),t;t[r++]=i.value}},ke=function(n){function o(i){var e;return(e=n.call(this)||this).name="GraphError",e.message=i,e}return E(o,n),o}(O(Error)),y=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="InvalidArgumentsGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(m(e),o.prototype.constructor),e}return E(o,n),o}(ke),f=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="NotFoundGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(m(e),o.prototype.constructor),e}return E(o,n),o}(ke),S=function(n){function o(i){var e;return(e=n.call(this,i)||this).name="UsageGraphError","function"==typeof Error.captureStackTrace&&Error.captureStackTrace(m(e),o.prototype.constructor),e}return E(o,n),o}(ke);function Le(n,o){this.key=n,this.attributes=o,this.clear()}function Ce(n,o){this.key=n,this.attributes=o,this.clear()}function Oe(n,o){this.key=n,this.attributes=o,this.clear()}function de(n,o,i,e,t){this.key=o,this.attributes=t,this.undirected=n,this.source=i,this.target=e}function re(n,o,i,e,t,r,a){var s,u,c,h;if(e=""+e,0===i){if(!(s=n._nodes.get(e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" node in the graph.'));c=t,h=r}else if(3===i){if(!(u=n._edges.get(t=""+t)))throw new f("Graph.".concat(o,': could not find the "').concat(t,'" edge in the graph.'));var d=u.source.key,l=u.target.key;if(e===d)s=u.target;else{if(e!==l)throw new f("Graph.".concat(o,': the "').concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(d,", ").concat(l,")."));s=u.source}c=r,h=a}else{if(!(u=n._edges.get(e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'));s=1===i?u.source:u.target,c=t,h=r}return[s,c,h]}Le.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.undirectedDegree=0,this.in={},this.out={},this.undirected={}},Ce.prototype.clear=function(){this.inDegree=0,this.outDegree=0,this.in={},this.out={}},Oe.prototype.clear=function(){this.undirectedDegree=0,this.undirected={}},de.prototype.attach=function(){var n="out",o="in";this.undirected&&(n=o="undirected");var i=this.source.key,e=this.target.key;this.source[n][e]=this,this.undirected&&i===e||(this.target[o][i]=this)},de.prototype.attachMulti=function(){var n="out",o="in",i=this.source.key,e=this.target.key;this.undirected&&(n=o="undirected");var t=this.source[n],r=t[e];if(void 0===r)return t[e]=this,void(this.undirected&&i===e||(this.target[o][i]=this));r.previous=this,this.next=r,t[e]=this,this.target[o][i]=this},de.prototype.detach=function(){var n=this.source.key,i="out",e="in";this.undirected&&(i=e="undirected"),delete this.source[i][this.target.key],delete this.target[e][n]},de.prototype.detachMulti=function(){var n=this.source.key,o=this.target.key,i="out",e="in";this.undirected&&(i=e="undirected"),void 0===this.previous?void 0===this.next?(delete this.source[i][o],delete this.target[e][n]):(this.next.previous=void 0,this.source[i][o]=this.next,this.target[e][n]=this.next):(this.previous.next=this.next,void 0!==this.next&&(this.next.previous=this.previous))};var Qe=[{name:function(n){return"get".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r);return a[0].attributes[a[1]]}}},{name:function(n){return"get".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){return re(this,o,i,e,t)[0].attributes}}},{name:function(n){return"has".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r);return a[0].attributes.hasOwnProperty(a[1])}}},{name:function(n){return"set".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r,a){var s=re(this,o,i,e,t,r,a),u=s[0],c=s[1];return u.attributes[c]=s[2],this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:c}),this}}},{name:function(n){return"update".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r,a){var s=re(this,o,i,e,t,r,a),u=s[0],c=s[1],h=s[2];if("function"!=typeof h)throw new y("Graph.".concat(o,": updater should be a function."));var d=u.attributes,l=h(d[c]);return d[c]=l,this.emit("nodeAttributesUpdated",{key:u.key,type:"set",attributes:u.attributes,name:c}),this}}},{name:function(n){return"remove".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),s=a[0],u=a[1];return delete s.attributes[u],this.emit("nodeAttributesUpdated",{key:s.key,type:"remove",attributes:s.attributes,name:u}),this}}},{name:function(n){return"replace".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),s=a[0],u=a[1];if(!b(u))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return s.attributes=u,this.emit("nodeAttributesUpdated",{key:s.key,type:"replace",attributes:s.attributes}),this}}},{name:function(n){return"merge".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),s=a[0],u=a[1];if(!b(u))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return G(s.attributes,u),this.emit("nodeAttributesUpdated",{key:s.key,type:"merge",attributes:s.attributes,data:u}),this}}},{name:function(n){return"update".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a=re(this,o,i,e,t,r),s=a[0],u=a[1];if("function"!=typeof u)throw new y("Graph.".concat(o,": provided updater is not a function."));return s.attributes=u(s.attributes),this.emit("nodeAttributesUpdated",{key:s.key,type:"update",attributes:s.attributes}),this}}}],Je=[{name:function(n){return"get".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return r.attributes[t]}}},{name:function(n){return"get".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e){var t;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>1){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var r=""+e,a=""+arguments[1];if(!(t=z(this,r,a,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(r,'" - "').concat(a,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(t=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return t.attributes}}},{name:function(n){return"has".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return r.attributes.hasOwnProperty(t)}}},{name:function(n){return"set".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var s=""+e,u=""+t;if(t=arguments[2],r=arguments[3],!(a=z(this,s,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(s,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(a=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return a.attributes[t]=r,this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:t}),this}}},{name:function(n){return"update".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t,r){var a;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>3){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var s=""+e,u=""+t;if(t=arguments[2],r=arguments[3],!(a=z(this,s,u,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(s,'" - "').concat(u,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(a=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof r)throw new y("Graph.".concat(o,": updater should be a function."));return a.attributes[t]=r(a.attributes[t]),this.emit("edgeAttributesUpdated",{key:a.key,type:"set",attributes:a.attributes,name:t}),this}}},{name:function(n){return"remove".concat(n,"Attribute")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}return delete r.attributes[t],this.emit("edgeAttributesUpdated",{key:r.key,type:"remove",attributes:r.attributes,name:t}),this}}},{name:function(n){return"replace".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if(!b(t))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return r.attributes=t,this.emit("edgeAttributesUpdated",{key:r.key,type:"replace",attributes:r.attributes}),this}}},{name:function(n){return"merge".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if(!b(t))throw new y("Graph.".concat(o,": provided attributes are not a plain object."));return G(r.attributes,t),this.emit("edgeAttributesUpdated",{key:r.key,type:"merge",attributes:r.attributes,data:t}),this}}},{name:function(n){return"update".concat(n,"Attributes")},attacher:function(n,o,i){n.prototype[o]=function(e,t){var r;if("mixed"!==this.type&&"mixed"!==i&&i!==this.type)throw new S("Graph.".concat(o,": cannot find this type of edges in your ").concat(this.type," graph."));if(arguments.length>2){if(this.multi)throw new S("Graph.".concat(o,": cannot use a {source,target} combo when asking about an edge's attributes in a MultiGraph since we cannot infer the one you want information about."));var a=""+e,s=""+t;if(t=arguments[2],!(r=z(this,a,s,i)))throw new f("Graph.".concat(o,': could not find an edge for the given path ("').concat(a,'" - "').concat(s,'").'))}else{if("mixed"!==i)throw new S("Graph.".concat(o,": calling this method with only a key (vs. a source and target) does not make sense since an edge with this key could have the other type."));if(!(r=this._edges.get(e=""+e)))throw new f("Graph.".concat(o,': could not find the "').concat(e,'" edge in the graph.'))}if("function"!=typeof t)throw new y("Graph.".concat(o,": provided updater is not a function."));return r.attributes=t(r.attributes),this.emit("edgeAttributesUpdated",{key:r.key,type:"update",attributes:r.attributes}),this}}}],He=T,Xe=Ne,ie=function(){var n=arguments,o=null,i=-1;return new He(function(){for(var e=null;;){if(null===o){if(++i>=n.length)return{done:!0};o=Xe(n[i])}if(!0!==(e=o.next()).done)break;o=null}return e})},Ze=[{name:"edges",type:"mixed"},{name:"inEdges",type:"directed",direction:"in"},{name:"outEdges",type:"directed",direction:"out"},{name:"inboundEdges",type:"mixed",direction:"in"},{name:"outboundEdges",type:"mixed",direction:"out"},{name:"directedEdges",type:"directed"},{name:"undirectedEdges",type:"undirected"}];function et(n,o,i,e){var t=!1;for(var r in o)if(r!==e){var a=o[r];if(t=i(a.key,a.attributes,a.source.key,a.target.key,a.source.attributes,a.target.attributes,a.undirected),n&&t)return a.key}}function tt(n,o,i,e){var t,r,a,s=!1;for(var u in o)if(u!==e){t=o[u];do{if(s=i(t.key,t.attributes,(r=t.source).key,(a=t.target).key,r.attributes,a.attributes,t.undirected),n&&s)return t.key;t=t.next}while(void 0!==t)}}function _e(n,o){var i,e=Object.keys(n),t=e.length,r=0;return new T(function(){do{if(i)i=i.next;else{if(r>=t)return{done:!0};var a=e[r++];if(a===o){i=void 0;continue}i=n[a]}}while(!i);return{done:!1,value:{edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected}}})}function nt(n,o,i,e){var t=o[i];if(t){var r=t.source,a=t.target;return e(t.key,t.attributes,r.key,a.key,r.attributes,a.attributes,t.undirected)&&n?t.key:void 0}}function rt(n,o,i,e){var t=o[i];if(t){var r=!1;do{if(r=e(t.key,t.attributes,t.source.key,t.target.key,t.source.attributes,t.target.attributes,t.undirected),n&&r)return t.key;t=t.next}while(void 0!==t)}}function Ee(n,o){var i=n[o];return void 0!==i.next?new T(function(){if(!i)return{done:!0};var e={edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected};return i=i.next,{done:!1,value:e}}):T.of({edge:i.key,attributes:i.attributes,source:i.source.key,target:i.target.key,sourceAttributes:i.source.attributes,targetAttributes:i.target.attributes,undirected:i.undirected})}function it(n,o){if(0===n.size)return[];if("mixed"===o||o===n.type)return"function"==typeof Array.from?Array.from(n._edges.keys()):Ue(n._edges.keys(),n._edges.size);for(var i,e,r=new Array("undirected"===o?n.undirectedSize:n.directedSize),a="undirected"===o,s=n._edges.values(),u=0;!0!==(i=s.next()).done;)(e=i.value).undirected===a&&(r[u++]=e.key);return r}function ze(n,o,i,e){if(0!==o.size)for(var t,r,a="mixed"!==i&&i!==o.type,s="undirected"===i,u=!1,c=o._edges.values();!0!==(t=c.next()).done;)if(r=t.value,!a||r.undirected===s){var d=r.key,p=r.source,k=r.target;if(u=e(d,r.attributes,p.key,k.key,p.attributes,k.attributes,r.undirected),n&&u)return d}}function ot(n,o){if(0===n.size)return T.empty();var i="mixed"!==o&&o!==n.type,e="undirected"===o,t=n._edges.values();return new T(function(){for(var r,a;;){if((r=t.next()).done)return r;if(a=r.value,!i||a.undirected===e)break}return{value:{edge:a.key,attributes:a.attributes,source:a.source.key,target:a.target.key,sourceAttributes:a.source.attributes,targetAttributes:a.target.attributes,undirected:a.undirected},done:!1}})}function Ge(n,o,i,e,t,r){var a,s=o?tt:et;if("undirected"!==i&&("out"!==e&&(a=s(n,t.in,r),n&&a)||"in"!==e&&(a=s(n,t.out,r,e?void 0:t.key),n&&a))||"directed"!==i&&(a=s(n,t.undirected,r),n&&a))return a}function at(n,o,i,e){var t=[];return Ge(!1,n,o,i,e,function(r){t.push(r)}),t}function st(n,o,i){var e=T.empty();return"undirected"!==n&&("out"!==o&&void 0!==i.in&&(e=ie(e,_e(i.in))),"in"!==o&&void 0!==i.out&&(e=ie(e,_e(i.out,o?void 0:i.key)))),"directed"!==n&&void 0!==i.undirected&&(e=ie(e,_e(i.undirected))),e}function xe(n,o,i,e,t,r,a){var s,u=i?rt:nt;if("undirected"!==o&&(void 0!==t.in&&"out"!==e&&(s=u(n,t.in,r,a),n&&s)||void 0!==t.out&&"in"!==e&&(e||t.key!==r)&&(s=u(n,t.out,r,a),n&&s))||"directed"!==o&&void 0!==t.undirected&&(s=u(n,t.undirected,r,a),n&&s))return s}function ut(n,o,i,e,t){var r=[];return xe(!1,n,o,i,e,t,function(a){r.push(a)}),r}function ct(n,o,i,e){var t=T.empty();return"undirected"!==n&&(void 0!==i.in&&"out"!==o&&e in i.in&&(t=ie(t,Ee(i.in,e))),void 0!==i.out&&"in"!==o&&e in i.out&&(o||i.key!==e)&&(t=ie(t,Ee(i.out,e)))),"directed"!==n&&void 0!==i.undirected&&e in i.undirected&&(t=ie(t,Ee(i.undirected,e))),t}var dt=[{name:"neighbors",type:"mixed"},{name:"inNeighbors",type:"directed",direction:"in"},{name:"outNeighbors",type:"directed",direction:"out"},{name:"inboundNeighbors",type:"mixed",direction:"in"},{name:"outboundNeighbors",type:"mixed",direction:"out"},{name:"directedNeighbors",type:"directed"},{name:"undirectedNeighbors",type:"undirected"}];function ye(){this.A=null,this.B=null}function le(n,o,i,e,t){for(var r in e){var a=e[r],s=a.source,c=s===i?a.target:s;if(!o||!o.has(c.key)){var h=t(c.key,c.attributes);if(n&&h)return c.key}}}function Ae(n,o,i,e,t){if("mixed"!==o){if("undirected"===o)return le(n,null,e,e.undirected,t);if("string"==typeof i)return le(n,null,e,e[i],t)}var r,a=new ye;if("undirected"!==o){if("out"!==i){if(r=le(n,null,e,e.in,t),n&&r)return r;a.wrap(e.in)}if("in"!==i){if(r=le(n,a,e,e.out,t),n&&r)return r;a.wrap(e.out)}}if("directed"!==o&&(r=le(n,a,e,e.undirected,t),n&&r))return r}function ge(n,o,i){var e=Object.keys(i),t=e.length,r=0;return new T(function(){var a=null;do{if(r>=t)return n&&n.wrap(i),{done:!0};var s=i[e[r++]],u=s.source;a=u===o?s.target:u,n&&n.has(a.key)&&(a=null)}while(null===a);return{done:!1,value:{neighbor:a.key,attributes:a.attributes}}})}function me(n,o,i,e,t){for(var r,a,s,u,c,h,d,l=e._nodes.values(),p=e.type;!0!==(r=l.next()).done;){var k=!1;if(a=r.value,"undirected"!==p)for(s in u=a.out){c=u[s];do{if(k=!0,d=t(a.key,(h=c.target).key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),n&&d)return c;c=c.next}while(c)}if("directed"!==p)for(s in u=a.undirected)if(!(o&&a.key>s)){c=u[s];do{if((h=c.target).key!==s&&(h=c.source),k=!0,d=t(a.key,h.key,a.attributes,h.attributes,c.key,c.attributes,c.undirected),n&&d)return c;c=c.next}while(c)}if(i&&!k&&(d=t(a.key,null,a.attributes,null,null,null,null),n&&d))return null}}function pt(n){if(!b(n))throw new y('Graph.import: invalid serialized node. A serialized node should be a plain object with at least a "key" property.');if(!("key"in n))throw new y("Graph.import: serialized node is missing its key.");if("attributes"in n&&(!b(n.attributes)||null===n.attributes))throw new y("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.")}function lt(n){if(!b(n))throw new y('Graph.import: invalid serialized edge. A serialized edge should be a plain object with at least a "source" & "target" property.');if(!("source"in n))throw new y("Graph.import: serialized edge is missing its source.");if(!("target"in n))throw new y("Graph.import: serialized edge is missing its target.");if("attributes"in n&&(!b(n.attributes)||null===n.attributes))throw new y("Graph.import: invalid attributes. Attributes should be a plain object, null or omitted.");if("undirected"in n&&"boolean"!=typeof n.undirected)throw new y("Graph.import: invalid undirectedness information. Undirected should be boolean or omitted.")}ye.prototype.wrap=function(n){null===this.A?this.A=n:null===this.B&&(this.B=n)},ye.prototype.has=function(n){return null!==this.A&&n in this.A||null!==this.B&&n in this.B};var je,gt=(je=255&Math.floor(256*Math.random()),function(){return je++}),yt=new Set(["directed","undirected","mixed"]),Me=new Set(["domain","_events","_eventsCount","_maxListeners"]),mt={allowSelfLoops:!0,multi:!1,type:"mixed"};function We(n,o,i){var e=new n.NodeDataClass(o,i);return n._nodes.set(o,e),n.emit("nodeAdded",{key:o,attributes:i}),e}function Pe(n,o,i,e,t,r,a,s){if(!e&&"undirected"===n.type)throw new S("Graph.".concat(o,": you cannot add a directed edge to an undirected graph. Use the #.addEdge or #.addUndirectedEdge instead."));if(e&&"directed"===n.type)throw new S("Graph.".concat(o,": you cannot add an undirected edge to a directed graph. Use the #.addEdge or #.addDirectedEdge instead."));if(s&&!b(s))throw new y("Graph.".concat(o,': invalid attributes. Expecting an object but got "').concat(s,'"'));if(r=""+r,a=""+a,s=s||{},!n.allowSelfLoops&&r===a)throw new S("Graph.".concat(o,': source & target are the same ("').concat(r,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var u=n._nodes.get(r),c=n._nodes.get(a);if(!u)throw new f("Graph.".concat(o,': source node "').concat(r,'" not found.'));if(!c)throw new f("Graph.".concat(o,': target node "').concat(a,'" not found.'));var h={key:null,undirected:e,source:r,target:a,attributes:s};if(i)t=n._edgeKeyGenerator();else if(n._edges.has(t=""+t))throw new S("Graph.".concat(o,': the "').concat(t,'" edge already exists in the graph.'));if(!n.multi&&(e?void 0!==u.undirected[a]:void 0!==u.out[a]))throw new S("Graph.".concat(o,': an edge linking "').concat(r,'" to "').concat(a,"\" already exists. If you really want to add multiple edges linking those nodes, you should create a multi graph by using the 'multi' option."));var d=new de(e,t,u,c,s);n._edges.set(t,d);var l=r===a;return e?(u.undirectedDegree++,c.undirectedDegree++,l&&n._undirectedSelfLoopCount++):(u.outDegree++,c.inDegree++,l&&n._directedSelfLoopCount++),n.multi?d.attachMulti():d.attach(),e?n._undirectedSize++:n._directedSize++,h.key=t,n.emit("edgeAdded",h),t}function vt(n,o,i,e,t,r,a,s,u){if(!e&&"undirected"===n.type)throw new S("Graph.".concat(o,": you cannot merge/update a directed edge to an undirected graph. Use the #.mergeEdge/#.updateEdge or #.addUndirectedEdge instead."));if(e&&"directed"===n.type)throw new S("Graph.".concat(o,": you cannot merge/update an undirected edge to a directed graph. Use the #.mergeEdge/#.updateEdge or #.addDirectedEdge instead."));if(s)if(u){if("function"!=typeof s)throw new y("Graph.".concat(o,': invalid updater function. Expecting a function but got "').concat(s,'"'))}else if(!b(s))throw new y("Graph.".concat(o,': invalid attributes. Expecting an object but got "').concat(s,'"'));var c;if(r=""+r,a=""+a,u&&(c=s,s=void 0),!n.allowSelfLoops&&r===a)throw new S("Graph.".concat(o,': source & target are the same ("').concat(r,"\"), thus creating a loop explicitly forbidden by this graph 'allowSelfLoops' option set to false."));var h,d,l=n._nodes.get(r),p=n._nodes.get(a);if(!i&&(h=n._edges.get(t))){if(!(h.source.key===r&&h.target.key===a||e&&h.source.key===a&&h.target.key===r))throw new S("Graph.".concat(o,': inconsistency detected when attempting to merge the "').concat(t,'" edge with "').concat(r,'" source & "').concat(a,'" target vs. ("').concat(h.source.key,'", "').concat(h.target.key,'").'));d=h}if(d||n.multi||!l||(d=e?l.undirected[a]:l.out[a]),d){var k=[d.key,!1,!1,!1];return(u?c:s)?(u?(d.attributes=c(d.attributes),n.emit("edgeAttributesUpdated",{type:"replace",key:d.key,attributes:d.attributes})):(G(d.attributes,s),n.emit("edgeAttributesUpdated",{type:"merge",key:d.key,attributes:d.attributes,data:s})),k):k}s=s||{},u&&c&&(s=c(s));var F={key:null,undirected:e,source:r,target:a,attributes:s};if(i)t=n._edgeKeyGenerator();else if(n._edges.has(t=""+t))throw new S("Graph.".concat(o,': the "').concat(t,'" edge already exists in the graph.'));var Y=!1,I=!1;l||(l=We(n,r,{}),Y=!0,r===a&&(p=l,I=!0)),p||(p=We(n,a,{}),I=!0),h=new de(e,t,l,p,s),n._edges.set(t,h);var $=r===a;return e?(l.undirectedDegree++,p.undirectedDegree++,$&&n._undirectedSelfLoopCount++):(l.outDegree++,p.inDegree++,$&&n._directedSelfLoopCount++),n.multi?h.attachMulti():h.attach(),e?n._undirectedSize++:n._directedSize++,F.key=t,n.emit("edgeAdded",F),[t,!0,Y,I]}function he(n,o){n._edges.delete(o.key);var i=o.source,e=o.target,t=o.attributes,r=o.undirected,a=i===e;r?(i.undirectedDegree--,e.undirectedDegree--,a&&n._undirectedSelfLoopCount--):(i.outDegree--,e.inDegree--,a&&n._directedSelfLoopCount--),n.multi?o.detachMulti():o.detach(),r?n._undirectedSize--:n._directedSize--,n.emit("edgeDropped",{key:o.key,attributes:t,source:i.key,target:e.key,undirected:r})}var n,B=function(n){function o(e){var t;if(t=n.call(this)||this,"boolean"!=typeof(e=G({},mt,e)).multi)throw new y("Graph.constructor: invalid 'multi' option. Expecting a boolean but got \"".concat(e.multi,'".'));if(!yt.has(e.type))throw new y('Graph.constructor: invalid \'type\' option. Should be one of "mixed", "directed" or "undirected" but got "'.concat(e.type,'".'));if("boolean"!=typeof e.allowSelfLoops)throw new y("Graph.constructor: invalid 'allowSelfLoops' option. Expecting a boolean but got \"".concat(e.allowSelfLoops,'".'));var r="mixed"===e.type?Le:"directed"===e.type?Ce:Oe;_(m(t),"NodeDataClass",r);var a="geid_"+gt()+"_",s=0;return _(m(t),"_attributes",{}),_(m(t),"_nodes",new Map),_(m(t),"_edges",new Map),_(m(t),"_directedSize",0),_(m(t),"_undirectedSize",0),_(m(t),"_directedSelfLoopCount",0),_(m(t),"_undirectedSelfLoopCount",0),_(m(t),"_edgeKeyGenerator",function(){var u;do{u=a+s++}while(t._edges.has(u));return u}),_(m(t),"_options",e),Me.forEach(function(u){return _(m(t),u,t[u])}),w(m(t),"order",function(){return t._nodes.size}),w(m(t),"size",function(){return t._edges.size}),w(m(t),"directedSize",function(){return t._directedSize}),w(m(t),"undirectedSize",function(){return t._undirectedSize}),w(m(t),"selfLoopCount",function(){return t._directedSelfLoopCount+t._undirectedSelfLoopCount}),w(m(t),"directedSelfLoopCount",function(){return t._directedSelfLoopCount}),w(m(t),"undirectedSelfLoopCount",function(){return t._undirectedSelfLoopCount}),w(m(t),"multi",t._options.multi),w(m(t),"type",t._options.type),w(m(t),"allowSelfLoops",t._options.allowSelfLoops),w(m(t),"implementation",function(){return"graphology"}),t}E(o,n);var i=o.prototype;return i._resetInstanceCounters=function(){this._directedSize=0,this._undirectedSize=0,this._directedSelfLoopCount=0,this._undirectedSelfLoopCount=0},i.hasNode=function(e){return this._nodes.has(""+e)},i.hasDirectedEdge=function(e,t){if("undirected"===this.type)return!1;if(1===arguments.length){var a=this._edges.get(""+e);return!!a&&!a.undirected}if(2===arguments.length){t=""+t;var s=this._nodes.get(e=""+e);if(!s)return!1;var u=s.out[t];return!(!u||this.multi&&!u.size)}throw new y("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasUndirectedEdge=function(e,t){if("directed"===this.type)return!1;if(1===arguments.length){var a=this._edges.get(""+e);return!!a&&a.undirected}if(2===arguments.length){t=""+t;var s=this._nodes.get(e=""+e);if(!s)return!1;var u=s.undirected[t];return!(!u||this.multi&&!u.size)}throw new y("Graph.hasDirectedEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.hasEdge=function(e,t){if(1===arguments.length)return this._edges.has(""+e);if(2===arguments.length){t=""+t;var a=this._nodes.get(e=""+e);if(!a)return!1;var s=void 0!==a.out&&a.out[t];return s||(s=void 0!==a.undirected&&a.undirected[t]),!(!s||this.multi&&!s.size)}throw new y("Graph.hasEdge: invalid arity (".concat(arguments.length,", instead of 1 or 2). You can either ask for an edge id or for the existence of an edge between a source & a target."))},i.directedEdge=function(e,t){if("undirected"!==this.type){if(e=""+e,t=""+t,this.multi)throw new S("Graph.directedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.directedEdges instead.");var r=this._nodes.get(e);if(!r)throw new f('Graph.directedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.directedEdge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.out&&r.out[t]||void 0;return a?a.key:void 0}},i.undirectedEdge=function(e,t){if("directed"!==this.type){if(e=""+e,t=""+t,this.multi)throw new S("Graph.undirectedEdge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.undirectedEdges instead.");var r=this._nodes.get(e);if(!r)throw new f('Graph.undirectedEdge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.undirectedEdge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.undirected&&r.undirected[t]||void 0;return a?a.key:void 0}},i.edge=function(e,t){if(this.multi)throw new S("Graph.edge: this method is irrelevant with multigraphs since there might be multiple edges between source & target. See #.edges instead.");t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.edge: could not find the "'.concat(e,'" source node in the graph.'));if(!this._nodes.has(t))throw new f('Graph.edge: could not find the "'.concat(t,'" target node in the graph.'));var a=r.out&&r.out[t]||r.undirected&&r.undirected[t]||void 0;if(a)return a.key},i.areDirectedNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areDirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in r.in||t in r.out)},i.areOutNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areOutNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.out},i.areInNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areInNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.in},i.areUndirectedNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areUndirectedNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"directed"!==this.type&&t in r.undirected},i.areNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&(t in r.in||t in r.out)||"directed"!==this.type&&t in r.undirected},i.areInboundNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areInboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.in||"directed"!==this.type&&t in r.undirected},i.areOutboundNeighbors=function(e,t){t=""+t;var r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.areOutboundNeighbors: could not find the "'.concat(e,'" node in the graph.'));return"undirected"!==this.type&&t in r.out||"directed"!==this.type&&t in r.undirected},i.inDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree},i.outDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.outDegree},i.directedDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.directedDegree: could not find the "'.concat(e,'" node in the graph.'));return"undirected"===this.type?0:t.inDegree+t.outDegree},i.undirectedDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.undirectedDegree: could not find the "'.concat(e,'" node in the graph.'));return"directed"===this.type?0:t.undirectedDegree},i.inboundDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inboundDegree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree),r},i.outboundDegree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outboundDegree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.outDegree),r},i.degree=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.degree: could not find the "'.concat(e,'" node in the graph.'));var r=0;return"directed"!==this.type&&(r+=t.undirectedDegree),"undirected"!==this.type&&(r+=t.inDegree+t.outDegree),r},i.inDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.inDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.in[e];return t.inDegree-(r?this.multi?r.size:1:0)},i.outDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.outDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.out[e];return t.outDegree-(r?this.multi?r.size:1:0)},i.directedDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.directedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("undirected"===this.type)return 0;var r=t.out[e];return t.inDegree+t.outDegree-2*(r?this.multi?r.size:1:0)},i.undirectedDegreeWithoutSelfLoops=function(e){var t=this._nodes.get(e=""+e);if(!t)throw new f('Graph.undirectedDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));if("directed"===this.type)return 0;var r=t.undirected[e];return t.undirectedDegree-2*(r?this.multi?r.size:1:0)},i.inboundDegreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.inboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,s=0;return"directed"!==this.type&&(a+=r.undirectedDegree,s+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.inDegree,s+=(t=r.out[e])?this.multi?t.size:1:0),a-s},i.outboundDegreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.outboundDegreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,s=0;return"directed"!==this.type&&(a+=r.undirectedDegree,s+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.outDegree,s+=(t=r.in[e])?this.multi?t.size:1:0),a-s},i.degreeWithoutSelfLoops=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.degreeWithoutSelfLoops: could not find the "'.concat(e,'" node in the graph.'));var a=0,s=0;return"directed"!==this.type&&(a+=r.undirectedDegree,s+=2*((t=r.undirected[e])?this.multi?t.size:1:0)),"undirected"!==this.type&&(a+=r.inDegree+r.outDegree,s+=2*((t=r.out[e])?this.multi?t.size:1:0)),a-s},i.source=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.source: could not find the "'.concat(e,'" edge in the graph.'));return t.source.key},i.target=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.target: could not find the "'.concat(e,'" edge in the graph.'));return t.target.key},i.extremities=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.extremities: could not find the "'.concat(e,'" edge in the graph.'));return[t.source.key,t.target.key]},i.opposite=function(e,t){e=""+e;var r=this._edges.get(t=""+t);if(!r)throw new f('Graph.opposite: could not find the "'.concat(t,'" edge in the graph.'));var a=r.source.key,s=r.target.key;if(e===a)return s;if(e===s)return a;throw new f('Graph.opposite: the "'.concat(e,'" node is not attached to the "').concat(t,'" edge (').concat(a,", ").concat(s,")."))},i.hasExtremity=function(e,t){t=""+t;var r=this._edges.get(e=""+e);if(!r)throw new f('Graph.hasExtremity: could not find the "'.concat(e,'" edge in the graph.'));return r.source.key===t||r.target.key===t},i.isUndirected=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isUndirected: could not find the "'.concat(e,'" edge in the graph.'));return t.undirected},i.isDirected=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isDirected: could not find the "'.concat(e,'" edge in the graph.'));return!t.undirected},i.isSelfLoop=function(e){var t=this._edges.get(e=""+e);if(!t)throw new f('Graph.isSelfLoop: could not find the "'.concat(e,'" edge in the graph.'));return t.source===t.target},i.addNode=function(e,t){return function(a,s,u){if(u&&!b(u))throw new y('Graph.addNode: invalid attributes. Expecting an object but got "'.concat(u,'"'));if(u=u||{},a._nodes.has(s=""+s))throw new S('Graph.addNode: the "'.concat(s,'" node already exist in the graph.'));var c=new a.NodeDataClass(s,u);return a._nodes.set(s,c),a.emit("nodeAdded",{key:s,attributes:u}),c}(this,e,t).key},i.mergeNode=function(e,t){if(t&&!b(t))throw new y('Graph.mergeNode: invalid attributes. Expecting an object but got "'.concat(t,'"'));t=t||{};var r=this._nodes.get(e=""+e);return r?(t&&(G(r.attributes,t),this.emit("nodeAttributesUpdated",{type:"merge",key:e,attributes:r.attributes,data:t})),[e,!1]):(r=new this.NodeDataClass(e,t),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:t}),[e,!0])},i.updateNode=function(e,t){if(t&&"function"!=typeof t)throw new y('Graph.updateNode: invalid updater function. Expecting a function but got "'.concat(t,'"'));var r=this._nodes.get(e=""+e);if(r)return t&&(r.attributes=t(r.attributes),this.emit("nodeAttributesUpdated",{type:"replace",key:e,attributes:r.attributes})),[e,!1];var s=t?t({}):{};return r=new this.NodeDataClass(e,s),this._nodes.set(e,r),this.emit("nodeAdded",{key:e,attributes:s}),[e,!0]},i.dropNode=function(e){var t,r=this._nodes.get(e=""+e);if(!r)throw new f('Graph.dropNode: could not find the "'.concat(e,'" node in the graph.'));if("undirected"!==this.type){for(var a in r.out){t=r.out[a];do{he(this,t),t=t.next}while(t)}for(var s in r.in){t=r.in[s];do{he(this,t),t=t.next}while(t)}}if("directed"!==this.type)for(var u in r.undirected){t=r.undirected[u];do{he(this,t),t=t.next}while(t)}this._nodes.delete(e),this.emit("nodeDropped",{key:e,attributes:r.attributes})},i.dropEdge=function(e){var t;if(arguments.length>1){var r=""+arguments[0],a=""+arguments[1];if(!(t=z(this,r,a,this.type)))throw new f('Graph.dropEdge: could not find the "'.concat(r,'" -> "').concat(a,'" edge in the graph.'))}else if(!(t=this._edges.get(e=""+e)))throw new f('Graph.dropEdge: could not find the "'.concat(e,'" edge in the graph.'));return he(this,t),this},i.dropDirectedEdge=function(e,t){if(arguments.length<2)throw new S("Graph.dropDirectedEdge: it does not make sense to try and drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new S("Graph.dropDirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=z(this,e=""+e,t=""+t,"directed");if(!r)throw new f('Graph.dropDirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return he(this,r),this},i.dropUndirectedEdge=function(e,t){if(arguments.length<2)throw new S("Graph.dropUndirectedEdge: it does not make sense to drop a directed edge by key. What if the edge with this key is undirected? Use #.dropEdge for this purpose instead.");if(this.multi)throw new S("Graph.dropUndirectedEdge: cannot use a {source,target} combo when dropping an edge in a MultiGraph since we cannot infer the one you want to delete as there could be multiple ones.");var r=z(this,e,t,"undirected");if(!r)throw new f('Graph.dropUndirectedEdge: could not find a "'.concat(e,'" -> "').concat(t,'" edge in the graph.'));return he(this,r),this},i.clear=function(){this._edges.clear(),this._nodes.clear(),this._resetInstanceCounters(),this.emit("cleared")},i.clearEdges=function(){for(var e,t=this._nodes.values();!0!==(e=t.next()).done;)e.value.clear();this._edges.clear(),this._resetInstanceCounters(),this.emit("edgesCleared")},i.getAttribute=function(e){return this._attributes[e]},i.getAttributes=function(){return this._attributes},i.hasAttribute=function(e){return this._attributes.hasOwnProperty(e)},i.setAttribute=function(e,t){return this._attributes[e]=t,this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},i.updateAttribute=function(e,t){if("function"!=typeof t)throw new y("Graph.updateAttribute: updater should be a function.");return this._attributes[e]=t(this._attributes[e]),this.emit("attributesUpdated",{type:"set",attributes:this._attributes,name:e}),this},i.removeAttribute=function(e){return delete this._attributes[e],this.emit("attributesUpdated",{type:"remove",attributes:this._attributes,name:e}),this},i.replaceAttributes=function(e){if(!b(e))throw new y("Graph.replaceAttributes: provided attributes are not a plain object.");return this._attributes=e,this.emit("attributesUpdated",{type:"replace",attributes:this._attributes}),this},i.mergeAttributes=function(e){if(!b(e))throw new y("Graph.mergeAttributes: provided attributes are not a plain object.");return G(this._attributes,e),this.emit("attributesUpdated",{type:"merge",attributes:this._attributes,data:e}),this},i.updateAttributes=function(e){if("function"!=typeof e)throw new y("Graph.updateAttributes: provided updater is not a function.");return this._attributes=e(this._attributes),this.emit("attributesUpdated",{type:"update",attributes:this._attributes}),this},i.updateEachNodeAttributes=function(e,t){if("function"!=typeof e)throw new y("Graph.updateEachNodeAttributes: expecting an updater function.");if(t&&!R(t))throw new y("Graph.updateEachNodeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var r,a,s=this._nodes.values();!0!==(r=s.next()).done;)(a=r.value).attributes=e(a.key,a.attributes);this.emit("eachNodeAttributesUpdated",{hints:t||null})},i.updateEachEdgeAttributes=function(e,t){if("function"!=typeof e)throw new y("Graph.updateEachEdgeAttributes: expecting an updater function.");if(t&&!R(t))throw new y("Graph.updateEachEdgeAttributes: invalid hints. Expecting an object having the following shape: {attributes?: [string]}");for(var r,a,s,u,c=this._edges.values();!0!==(r=c.next()).done;)s=(a=r.value).source,a.attributes=e(a.key,a.attributes,s.key,(u=a.target).key,s.attributes,u.attributes,a.undirected);this.emit("eachEdgeAttributesUpdated",{hints:t||null})},i.forEachAdjacencyEntry=function(e){if("function"!=typeof e)throw new y("Graph.forEachAdjacencyEntry: expecting a callback.");me(!1,!1,!1,this,e)},i.forEachAdjacencyEntryWithOrphans=function(e){if("function"!=typeof e)throw new y("Graph.forEachAdjacencyEntryWithOrphans: expecting a callback.");me(!1,!1,!0,this,e)},i.forEachAssymetricAdjacencyEntry=function(e){if("function"!=typeof e)throw new y("Graph.forEachAssymetricAdjacencyEntry: expecting a callback.");me(!1,!0,!1,this,e)},i.forEachAssymetricAdjacencyEntryWithOrphans=function(e){if("function"!=typeof e)throw new y("Graph.forEachAssymetricAdjacencyEntryWithOrphans: expecting a callback.");me(!1,!0,!0,this,e)},i.nodes=function(){return"function"==typeof Array.from?Array.from(this._nodes.keys()):Ue(this._nodes.keys(),this._nodes.size)},i.forEachNode=function(e){if("function"!=typeof e)throw new y("Graph.forEachNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)e((r=t.value).key,r.attributes)},i.findNode=function(e){if("function"!=typeof e)throw new y("Graph.findNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(e((r=t.value).key,r.attributes))return r.key},i.mapNodes=function(e){if("function"!=typeof e)throw new y("Graph.mapNode: expecting a callback.");for(var t,r,a=this._nodes.values(),s=new Array(this.order),u=0;!0!==(t=a.next()).done;)s[u++]=e((r=t.value).key,r.attributes);return s},i.someNode=function(e){if("function"!=typeof e)throw new y("Graph.someNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(e((r=t.value).key,r.attributes))return!0;return!1},i.everyNode=function(e){if("function"!=typeof e)throw new y("Graph.everyNode: expecting a callback.");for(var t,r,a=this._nodes.values();!0!==(t=a.next()).done;)if(!e((r=t.value).key,r.attributes))return!1;return!0},i.filterNodes=function(e){if("function"!=typeof e)throw new y("Graph.filterNodes: expecting a callback.");for(var t,r,a=this._nodes.values(),s=[];!0!==(t=a.next()).done;)e((r=t.value).key,r.attributes)&&s.push(r.key);return s},i.reduceNodes=function(e,t){if("function"!=typeof e)throw new y("Graph.reduceNodes: expecting a callback.");if(arguments.length<2)throw new y("Graph.reduceNodes: missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array.");for(var r,a,s=t,u=this._nodes.values();!0!==(r=u.next()).done;)s=e(s,(a=r.value).key,a.attributes);return s},i.nodeEntries=function(){var e=this._nodes.values();return new T(function(){var t=e.next();if(t.done)return t;var r=t.value;return{value:{node:r.key,attributes:r.attributes},done:!1}})},i.export=function(){var e=new Array(this._nodes.size),t=0;this._nodes.forEach(function(a,s){var c,h;e[t++]=(h={key:s},K((c=a).attributes)||(h.attributes=G({},c.attributes)),h)});var r=new Array(this._edges.size);return t=0,this._edges.forEach(function(a,s){var c,h;r[t++]=(h={key:s,source:(c=a).source.key,target:c.target.key},K(c.attributes)||(h.attributes=G({},c.attributes)),c.undirected&&(h.undirected=!0),h)}),{options:{type:this.type,multi:this.multi,allowSelfLoops:this.allowSelfLoops},attributes:this.getAttributes(),nodes:e,edges:r}},i.import=function(e){var t,r,a,s,u,c=this,h=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(D(e))return e.forEachNode(function(q,ee){h?c.mergeNode(q,ee):c.addNode(q,ee)}),e.forEachEdge(function(q,ee,se,ve,bt,kt,Te){h?Te?c.mergeUndirectedEdgeWithKey(q,se,ve,ee):c.mergeDirectedEdgeWithKey(q,se,ve,ee):Te?c.addUndirectedEdgeWithKey(q,se,ve,ee):c.addDirectedEdgeWithKey(q,se,ve,ee)}),this;if(!b(e))throw new y("Graph.import: invalid argument. Expecting a serialized graph or, alternatively, a Graph instance.");if(e.attributes){if(!b(e.attributes))throw new y("Graph.import: invalid attributes. Expecting a plain object.");h?this.mergeAttributes(e.attributes):this.replaceAttributes(e.attributes)}if(e.nodes){if(a=e.nodes,!Array.isArray(a))throw new y("Graph.import: invalid nodes. Expecting an array.");for(t=0,r=a.length;t<r;t++){pt(s=a[t]);var l=s.key,p=s.attributes;h?this.mergeNode(l,p):this.addNode(l,p)}}if(e.edges){if(a=e.edges,!Array.isArray(a))throw new y("Graph.import: invalid edges. Expecting an array.");for(t=0,r=a.length;t<r;t++){lt(u=a[t]);var M=u.source,F=u.target,Y=u.attributes,I=u.undirected,$=void 0!==I&&I;"key"in u?(h?$?this.mergeUndirectedEdgeWithKey:this.mergeDirectedEdgeWithKey:$?this.addUndirectedEdgeWithKey:this.addDirectedEdgeWithKey).call(this,u.key,M,F,Y):(h?$?this.mergeUndirectedEdge:this.mergeDirectedEdge:$?this.addUndirectedEdge:this.addDirectedEdge).call(this,M,F,Y)}}return this},i.nullCopy=function(e){var t=new o(G({},this._options,e));return t.replaceAttributes(G({},this.getAttributes())),t},i.emptyCopy=function(e){var t=this.nullCopy(e);return this._nodes.forEach(function(r,a){var s=G({},r.attributes);r=new t.NodeDataClass(a,s),t._nodes.set(a,r)}),t},i.copy=function(e){if("string"==typeof(e=e||{}).type&&e.type!==this.type&&"mixed"!==e.type)throw new S('Graph.copy: cannot create an incompatible copy from "'.concat(this.type,'" type to "').concat(e.type,'" because this would mean losing information about the current graph.'));if("boolean"==typeof e.multi&&e.multi!==this.multi&&!0!==e.multi)throw new S("Graph.copy: cannot create an incompatible copy by downgrading a multi graph to a simple one because this would mean losing information about the current graph.");if("boolean"==typeof e.allowSelfLoops&&e.allowSelfLoops!==this.allowSelfLoops&&!0!==e.allowSelfLoops)throw new S("Graph.copy: cannot create an incompatible copy from a graph allowing self loops to one that does not because this would mean losing information about the current graph.");for(var t,r,a=this.emptyCopy(e),s=this._edges.values();!0!==(t=s.next()).done;)Pe(a,"copy",!1,(r=t.value).undirected,r.key,r.source.key,r.target.key,G({},r.attributes));return a},i.toJSON=function(){return this.export()},i.toString=function(){return"[object Graph]"},i.inspect=function(){var e=this,t={};this._nodes.forEach(function(c,h){t[h]=c.attributes});var r={},a={};this._edges.forEach(function(c,h){var d,l=c.undirected?"--":"->",p="",k=c.source.key,M=c.target.key;c.undirected&&k>M&&(d=k,k=M,M=d);var F="(".concat(k,")").concat(l,"(").concat(M,")");h.startsWith("geid_")?e.multi&&(void 0===a[F]?a[F]=0:a[F]++,p+="".concat(a[F],". ")):p+="[".concat(h,"]: "),r[p+=F]=c.attributes});var s={};for(var u in this)this.hasOwnProperty(u)&&!Me.has(u)&&"function"!=typeof this[u]&&"symbol"!==W(u)&&(s[u]=this[u]);return s.attributes=this._attributes,s.nodes=t,s.edges=r,_(s,"constructor",this.constructor),s},o}(U.exports.EventEmitter);typeof Symbol<"u"&&(B.prototype[Symbol.for("nodejs.util.inspect.custom")]=B.prototype.inspect),[{name:function(n){return"".concat(n,"Edge")},generateKey:!0},{name:function(n){return"".concat(n,"DirectedEdge")},generateKey:!0,type:"directed"},{name:function(n){return"".concat(n,"UndirectedEdge")},generateKey:!0,type:"undirected"},{name:function(n){return"".concat(n,"EdgeWithKey")}},{name:function(n){return"".concat(n,"DirectedEdgeWithKey")},type:"directed"},{name:function(n){return"".concat(n,"UndirectedEdgeWithKey")},type:"undirected"}].forEach(function(n){["add","merge","update"].forEach(function(o){var i=n.name(o),e="add"===o?Pe:vt;B.prototype[i]=n.generateKey?function(t,r,a){return e(this,i,!0,"undirected"===(n.type||this.type),null,t,r,a,"update"===o)}:function(t,r,a,s){return e(this,i,!1,"undirected"===(n.type||this.type),t,r,a,s,"update"===o)}})}),n=B,Qe.forEach(function(o){var i=o.name,e=o.attacher;e(n,i("Node"),0),e(n,i("Source"),1),e(n,i("Target"),2),e(n,i("Opposite"),3)}),function(n){Je.forEach(function(o){var i=o.name,e=o.attacher;e(n,i("Edge"),"mixed"),e(n,i("DirectedEdge"),"directed"),e(n,i("UndirectedEdge"),"undirected")})}(B),function(n){Ze.forEach(function(o){var e,t,r,a;r=(e=o).type,a=e.direction,n.prototype[t=e.name]=function(s,u){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return[];if(!arguments.length)return it(this,r);if(1===arguments.length){var c=this._nodes.get(s=""+s);if(void 0===c)throw new f("Graph.".concat(t,': could not find the "').concat(s,'" node in the graph.'));return at(this.multi,"mixed"===r?this.type:r,a,c)}if(2===arguments.length){u=""+u;var h=this._nodes.get(s=""+s);if(!h)throw new f("Graph.".concat(t,':  could not find the "').concat(s,'" source node in the graph.'));if(!this._nodes.has(u))throw new f("Graph.".concat(t,':  could not find the "').concat(u,'" target node in the graph.'));return ut(r,this.multi,a,h,u)}throw new y("Graph.".concat(t,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))},function(i,e){var t=e.name,r=e.type,a=e.direction,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(d,l,p){if("mixed"===r||"mixed"===this.type||r===this.type){if(1===arguments.length)return ze(!1,this,r,p=d);if(2===arguments.length){p=l;var k=this._nodes.get(d=""+d);if(void 0===k)throw new f("Graph.".concat(s,': could not find the "').concat(d,'" node in the graph.'));return Ge(!1,this.multi,"mixed"===r?this.type:r,a,k,p)}if(3===arguments.length){l=""+l;var M=this._nodes.get(d=""+d);if(!M)throw new f("Graph.".concat(s,':  could not find the "').concat(d,'" source node in the graph.'));if(!this._nodes.has(l))throw new f("Graph.".concat(s,':  could not find the "').concat(l,'" target node in the graph.'));return xe(!1,r,this.multi,a,M,l,p)}throw new y("Graph.".concat(s,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))}};var u="map"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(){var d,l=Array.prototype.slice.call(arguments),p=l.pop();if(0===l.length){var k=0;"directed"!==r&&(k+=this.undirectedSize),"undirected"!==r&&(k+=this.directedSize),d=new Array(k);var M=0;l.push(function(F,Y,I,$,q,ee,se){d[M++]=p(F,Y,I,$,q,ee,se)})}else d=[],l.push(function(F,Y,I,$,q,ee,se){d.push(p(F,Y,I,$,q,ee,se))});return this[s].apply(this,l),d};var c="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(){var d=Array.prototype.slice.call(arguments),l=d.pop(),p=[];return d.push(function(k,M,F,Y,I,$,q){l(k,M,F,Y,I,$,q)&&p.push(k)}),this[s].apply(this,d),p};var h="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[h]=function(){var d,l,p=Array.prototype.slice.call(arguments);if(p.length<2||p.length>4)throw new y("Graph.".concat(h,": invalid number of arguments (expecting 2, 3 or 4 and got ").concat(p.length,")."));if("function"==typeof p[p.length-1]&&"function"!=typeof p[p.length-2])throw new y("Graph.".concat(h,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));2===p.length?(d=p[0],l=p[1],p=[]):3===p.length?(d=p[1],l=p[2],p=[p[0]]):4===p.length&&(d=p[2],l=p[3],p=[p[0],p[1]]);var k=l;return p.push(function(M,F,Y,I,$,q,ee){k=d(k,M,F,Y,I,$,q,ee)}),this[s].apply(this,p),k}}(n,o),function(i,e){var t=e.name,r=e.type,a=e.direction,s="find"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(h,d,l){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return!1;if(1===arguments.length)return ze(!0,this,r,l=h);if(2===arguments.length){l=d;var p=this._nodes.get(h=""+h);if(void 0===p)throw new f("Graph.".concat(s,': could not find the "').concat(h,'" node in the graph.'));return Ge(!0,this.multi,"mixed"===r?this.type:r,a,p,l)}if(3===arguments.length){d=""+d;var k=this._nodes.get(h=""+h);if(!k)throw new f("Graph.".concat(s,':  could not find the "').concat(h,'" source node in the graph.'));if(!this._nodes.has(d))throw new f("Graph.".concat(s,':  could not find the "').concat(d,'" target node in the graph.'));return xe(!0,r,this.multi,a,k,d,l)}throw new y("Graph.".concat(s,": too many arguments (expecting 1, 2 or 3 and got ").concat(arguments.length,")."))};var u="some"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[u]=function(){var h=Array.prototype.slice.call(arguments),d=h.pop();return h.push(function(l,p,k,M,F,Y,I){return d(l,p,k,M,F,Y,I)}),!!this[s].apply(this,h)};var c="every"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[c]=function(){var h=Array.prototype.slice.call(arguments),d=h.pop();return h.push(function(l,p,k,M,F,Y,I){return!d(l,p,k,M,F,Y,I)}),!this[s].apply(this,h)}}(n,o),function(i,e){var r=e.type,a=e.direction,s=e.name.slice(0,-1)+"Entries";i.prototype[s]=function(u,c){if("mixed"!==r&&"mixed"!==this.type&&r!==this.type)return T.empty();if(!arguments.length)return ot(this,r);if(1===arguments.length){var h=this._nodes.get(u=""+u);if(!h)throw new f("Graph.".concat(s,': could not find the "').concat(u,'" node in the graph.'));return st(r,a,h)}if(2===arguments.length){c=""+c;var d=this._nodes.get(u=""+u);if(!d)throw new f("Graph.".concat(s,':  could not find the "').concat(u,'" source node in the graph.'));if(!this._nodes.has(c))throw new f("Graph.".concat(s,':  could not find the "').concat(c,'" target node in the graph.'));return ct(r,a,d,c)}throw new y("Graph.".concat(s,": too many arguments (expecting 0, 1 or 2 and got ").concat(arguments.length,")."))}}(n,o)})}(B),function(n){dt.forEach(function(o){var i,e,t,r,a,s,u;(function ht(n,o){var i=o.name,e=o.type,t=o.direction;n.prototype[i]=function(r){if("mixed"!==e&&"mixed"!==this.type&&e!==this.type)return[];var a=this._nodes.get(r=""+r);if(void 0===a)throw new f("Graph.".concat(i,': could not find the "').concat(r,'" node in the graph.'));return function(s,u,c){if("mixed"!==s){if("undirected"===s)return Object.keys(c.undirected);if("string"==typeof u)return Object.keys(c[u])}var h=[];return Ae(!1,s,u,c,function(d){h.push(d)}),h}("mixed"===e?this.type:e,t,a)}})(n,o),function(i,e){var t=e.name,r=e.type,a=e.direction,s="forEach"+t[0].toUpperCase()+t.slice(1,-1);i.prototype[s]=function(d,l){if("mixed"===r||"mixed"===this.type||r===this.type){var p=this._nodes.get(d=""+d);if(void 0===p)throw new f("Graph.".concat(s,': could not find the "').concat(d,'" node in the graph.'));Ae(!1,"mixed"===r?this.type:r,a,p,l)}};var u="map"+t[0].toUpperCase()+t.slice(1);i.prototype[u]=function(d,l){var p=[];return this[s](d,function(k,M){p.push(l(k,M))}),p};var c="filter"+t[0].toUpperCase()+t.slice(1);i.prototype[c]=function(d,l){var p=[];return this[s](d,function(k,M){l(k,M)&&p.push(k)}),p};var h="reduce"+t[0].toUpperCase()+t.slice(1);i.prototype[h]=function(d,l,p){if(arguments.length<3)throw new y("Graph.".concat(h,": missing initial value. You must provide it because the callback takes more than one argument and we cannot infer the initial value from the first iteration, as you could with a simple array."));var k=p;return this[s](d,function(M,F){k=l(k,M,F)}),k}}(n,o),i=n,r=(e=o).type,a=e.direction,s=(t=e.name)[0].toUpperCase()+t.slice(1,-1),i.prototype[u="find"+s]=function(d,l){if("mixed"===r||"mixed"===this.type||r===this.type){var p=this._nodes.get(d=""+d);if(void 0===p)throw new f("Graph.".concat(u,': could not find the "').concat(d,'" node in the graph.'));return Ae(!0,"mixed"===r?this.type:r,a,p,l)}},i.prototype["some"+s]=function(d,l){return!!this[u](d,l)},i.prototype["every"+s]=function(d,l){return!this[u](d,function(p,k){return!l(p,k)})},function ft(n,o){var e=o.type,t=o.direction,r=o.name.slice(0,-1)+"Entries";n.prototype[r]=function(a){if("mixed"!==e&&"mixed"!==this.type&&e!==this.type)return T.empty();var s=this._nodes.get(a=""+a);if(void 0===s)throw new f("Graph.".concat(r,': could not find the "').concat(a,'" node in the graph.'));return function(u,c,h){if("mixed"!==u){if("undirected"===u)return ge(null,h,h.undirected);if("string"==typeof c)return ge(null,h,h[c])}var d=T.empty(),l=new ye;return"undirected"!==u&&("out"!==c&&(d=ie(d,ge(l,h,h.in))),"in"!==c&&(d=ie(d,ge(l,h,h.out)))),"directed"!==u&&(d=ie(d,ge(l,h,h.undirected))),d}("mixed"===e?this.type:e,t,s)}}(n,o)})}(B);var Re=function(n){function o(i){var e=G({type:"directed"},i);if("multi"in e&&!1!==e.multi)throw new y("DirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("directed"!==e.type)throw new y('DirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return E(o,n),o}(B),Ke=function(n){function o(i){var e=G({type:"undirected"},i);if("multi"in e&&!1!==e.multi)throw new y("UndirectedGraph.from: inconsistent indication that the graph should be multi in given options!");if("undirected"!==e.type)throw new y('UndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return E(o,n),o}(B),Be=function(n){function o(i){var e=G({multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiGraph.from: inconsistent indication that the graph should be simple in given options!");return n.call(this,e)||this}return E(o,n),o}(B),Fe=function(n){function o(i){var e=G({type:"directed",multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiDirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("directed"!==e.type)throw new y('MultiDirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return E(o,n),o}(B),Ie=function(n){function o(i){var e=G({type:"undirected",multi:!0},i);if("multi"in e&&!0!==e.multi)throw new y("MultiUndirectedGraph.from: inconsistent indication that the graph should be simple in given options!");if("undirected"!==e.type)throw new y('MultiUndirectedGraph.from: inconsistent "'+e.type+'" type in given options!');return n.call(this,e)||this}return E(o,n),o}(B);function fe(n){n.from=function(o,i){var e=G({},o.options,i),t=new n(e);return t.import(o),t}}return fe(B),fe(Re),fe(Ke),fe(Be),fe(Fe),fe(Ie),B.Graph=B,B.DirectedGraph=Re,B.UndirectedGraph=Ke,B.MultiGraph=Be,B.MultiDirectedGraph=Fe,B.MultiUndirectedGraph=Ie,B.InvalidArgumentsGraphError=y,B.NotFoundGraphError=f,B.UsageGraphError=S,B}()}},Se={};function we(Q){var W=Se[Q];if(void 0!==W)return W.exports;var E=Se[Q]={exports:{}};return Ye[Q].call(E.exports,E,E.exports,we),E.exports}(()=>{"use strict";var L,Q=we(5595),W=we(5149);function E(z,D,b){return"edge"==D.type?z.getEdgeAttribute(D.key,b):z.getNodeAttribute(D.key,b)}function N(z,D,b,K){"edge"==D.type?z.setEdgeAttribute(D.key,b,K):z.setNodeAttribute(D.key,b,K)}!function(z){let D,b;(D=z.staticChecks||(z.staticChecks={})).isConnected=function _(w){const R=(0,W.dQ)(w).nodes(),g=w.nodes();if(R.length==g.length)return{message:"",markings:[]};const U=[];return g.forEach(v=>{v in R||U.push(m.markElement(w,{key:v,type:"node"},"error"))}),{message:"A path between any pair of nodes in graph must exist",markings:U}},(b=z.dynamicChecks||(z.dynamicChecks={})).areAttributesInRange=function _(w,R,g,U){const{min:v,max:x}=U;if(void 0===v&&void 0===x)return{message:"",markings:[]};if(void 0!==v&&void 0!==x&&!(v<=x))throw new Error("areAttributesInRange in range GraphCheck is called improperly, conditions min <= max should be met");const j=[];"edge"==R?w.forEachEdge(C=>{(void 0!==v&&v>w.getEdgeAttribute(C,g)||void 0!==x&&x<w.getEdgeAttribute(C,g))&&j.push(m.markElement(w,{key:C,type:R},"error"))}):w.forEachNode(C=>{(void 0!==v&&v>w.getNodeAttribute(C,g)||void 0!==x&&x<w.getNodeAttribute(C,g))&&j.push(m.markElement(w,{key:C,type:R},"error"))});let A="";return j.length>0&&(A=`Value of ${g} on each ${R} must be ${void 0!==v?`higher than or equal to ${v}`:""}${void 0!==v&&void 0!==x?" and ":""}${void 0!==x?`lower than or equal to ${x}`:""}.`),{message:A,markings:j}}}(L||(L={}));const O={inspect:"yellow",approve:"green",reject:"red",choose:"blueviolet",error:"black"};class m{constructor(D,b,K,_){this.element=D,this.property=b,this.formerValue=K,this.newValue=_}static markElement(D,b,K){const _="color";let w=E(D,b,_);w in[O.choose,O.error]&&(w=void 0);const R=new m(b,_,w,O[K]);return R.apply(D),R}static setProperty(D,b,K,_){const w=E(D,b,K);void 0===w&&console.error(`Attempt to set value of nonexistent ${b.type} property ${K}.`);const R=new m(b,K,w,_);return R.apply(D),R}static areRedundant(D,b){return D.element==b.element&&D.property==b.property}apply(D){N(D,this.element,this.property,this.newValue)}reverse(D){void 0===this.formerValue?function P(z,D,b){"edge"==D.type?z.removeEdgeAttribute(D.key,b):z.removeNodeAttribute(D.key,b)}(D,this.element,this.property):N(D,this.element,this.property,this.formerValue)}}class G{constructor(){this.changes=[],this.description=""}addChange(D){const b=this.changes.findIndex(K=>{m.areRedundant(K,D)});-1==b?this.changes.push(D):this.changes[b]=D}apply(D){this.changes.forEach(b=>{b.apply(D)})}reverse(D){this.changes.forEach(b=>{b.reverse(D)})}}addEventListener("message",({data:z})=>{const{graphData:D,source:b,destination:K}=z,_=Q.UndirectedGraph.from(D);let w=new G;w.description="Starting node is set as current node and its distance from the start is set to 0. All nodes are considered to be unvisited.",w.addChange(m.markElement(_,{key:b,type:"node"},"inspect")),w.addChange(m.setProperty(_,{key:b,type:"node"},"distance",0)),postMessage(w);let R=_.nodes(),g=b;for(;g!=K;){w=new G,w.description="Edge connecting current node with one of its unvisited neighbors is inspected. If sum of distance of current node and length of the edge is lower than current distance of neighbor node, distance of neighbor node is set to sum.",_.forEachNeighbor(g,v=>{if(R.includes(v)){w.addChange(m.markElement(_,{key:_.edge(g,v),type:"edge"},"inspect"));const x=_.getNodeAttribute(g,"distance")+_.getEdgeAttribute(g,v,"cost");x<_.getNodeAttribute(v,"distance")&&w.addChange(m.setProperty(_,{key:v,type:"node"},"distance",x)),postMessage(w),w=new G,w.description="Edge connecting current node with one of its unvisited neighbors is inspected. If sum of distance of current node and length of the edge is lower than current distance of neighbor node, distance of neighbor node is set to sum.",w.addChange(m.markElement(_,{key:_.edge(g,v),type:"edge"},"reject"))}}),w.description="All of edges leading to unvisited neighbours have been inspected and it is considered as visited. Unvisited node with lowest distance from start is choosen as new current node.",w.addChange(m.markElement(_,{key:g,type:"node"},"reject"));const U=R.indexOf(g);R.splice(U,1),R.sort((v,x)=>{const j=_.getNodeAttribute(v,"distance"),A=_.getNodeAttribute(x,"distance");return j<A?-1:j>A?1:0}),g=R[0],w.addChange(m.markElement(_,{key:g,type:"node"},"inspect")),postMessage(w)}for(w=new G,w.description="Destination node has been choosen as current, which means that shortest path to it from start has been found.On the other ends of all uninspected edges leaving destination node lead to nodes that are farther from the start than it is. If algorithm were to continue beyond this point, shortest paths from start to all still unvisited points would be found.";g!=b;){w.addChange(m.markElement(_,{key:g,type:"node"},"approve"));const U=_.findNeighbor(g,(v,x)=>_.getEdgeAttribute(_.edge(g,v),"cost")+x.distance==_.getNodeAttribute(g,"distance"));w.addChange(m.markElement(_,{key:_.edge(g,U),type:"edge"},"approve")),g=U}w.addChange(m.markElement(_,{key:g,type:"node"},"approve")),postMessage(w)})})()})();